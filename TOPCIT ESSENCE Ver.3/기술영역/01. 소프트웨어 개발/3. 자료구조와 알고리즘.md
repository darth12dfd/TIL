# 자료구조와 알고리즘

## 자료 구조 

### 정의

* 자료구조란 자료를 컴퓨터의 기억장치 내에 저장하는 방법으로 다양한 자료를 효율적으로 표현하고 활용할 수 있도록 자료의 특성과 사용 용도를 고려하여 조직적, 체계적으로 정의한 것이다.

### 분류

* 자료구조 분류

| 분류 | 설명 |
| ---- | ---- |
| 선형구조 | 원시코드로부터 정보를 추출하여 물리적 설계 정보저장소에 저장<br>물리적 설계자료들이 직선형태로 나열되어 자료들 간의 순서를 고려한 구조로 전후/인접/선후 자료들 간의 1:1 관계로 나열됨.<br> 배열, 선형리스트, 연결리스트, 스택, 큐, 데크 등이 있음 <br> 정보를 얻어내는 역할 수행|
| 비선형구조 | 한 자료 뒤에 여러 개의 자료들이 존재하는 구조로 인접/전후 자료들 간의 1:다 또는 다:다 관계로 배치됨 <br> 종류는 트리와 그래프 등이 있음. |


* 순차 자료구조와 연결자료구조의 비교

| 구분 | 순차자료구조 | 연결자료구조 |
| ---- | ---- | ---- |
| 메모리 저장 방식 | 메모리 저장 시작위치부터 빈자리 없이 자료를 순서대로 연속적으로 저장하는 방식 | 메모리에 저장된 물리적 위치나 순서에 상관없이 링크에 의해 논리적인 순서를 표현하는 방식 |
| 논리/물리 순서 일치 여부 | 논리적인 순서와 물리적인 순서가 일치하는 방식 | 논리적인 순서와 물리적인 순서가 일치하지 않음 |
| 연산 특징 | 삽입, 삭제 연산 수행 후 빈자리가 없음. 자료가 순서대로 연속하여 저장 | 삽입, 삭제 연산으로 논리적인 순서가 변경되어도 링크 정보만 변경되어 물리적인 순서는 변경 안됨. |
| 프로그램 기법 | 배열을 이용한 구현 | 포인터를 이용한 구현 |

#### 스택과 큐

* 스택

- Lifo(Last In First Out) 방식: 마지막에 입력받은 자료가 가장 먼저 나가는 방식
- 연산자 종류

 ```
 top(): 스택의 맨 위에 있는 데이터 값 반환
 push(): 스택에 데이터 삽입
 pop(): 스택에 데이터를 삭제 및 반환
 isEmpty(): 스택에 원소가 없으면 true 값 반환, 있으면 false 값 반환
 isFull(): 스택에 원소가 없으면 false, 있으면 true 반환
 ```

* 큐

- Fifo(First In First out) 방식: 처음에 입력받은 자료가 가장 먼저 나가는 방식
- 연산자 종류

```
enQueue: 큐에 데이터를 삽입. rear(저장돤 자료 중 마지막 자료)를 움직여 큐의 공간을 확보한 후 데이터를 삽입
deQueue: 큐에 데이터를 삭제: front(저장된 자료 중 첫 번재 자료)를 움직여 가장 오래된 데이터를 다음 번째 데이터로 넘기게 된다.
```

* 스택, 큐의 연산 비교

| 항목 | 삽입 연산 | 삭제 연산 |
| ---- | ---- | ---- |
| 스택 | 연산자(push), 삽입 위치(top) | 연산자(pop), 삭제 위치(top) |
| 큐 | enQueue,rear | deQueue, front |


#### 트리와 그래프

* 트리

- 원소들 간의 계층 관계를 가지는 계층형 자료 구조로 상위 원소에서 하위 원소로 내려가면서 확장되는 나무 모양의 구조를 가짐. 원소들 간 1:다 관계 가짐.
- 트리의 시작노드를 루트노드라고 하고 노드를 연결하는 선을 간선(edge)라고 한다. 같은 부모 노드를 가진 자식 노드들을 형제노드라고 하고, 부모노드와 연결된 간선을 끊었을 때 생성되는 트리를 서브트리라고 한다.

* 그래프

- 연결되어 있는 원소 사이의 다:댜 관계를 표현하는 자료구조. 객체를 나타내는 정점과 객체를 연결하는 간선의 집합. 

- 그래프 종류

| 종류 | 설명 |
| ---- | ---- | 
| 무방향 그래프 | 그래프의 정점 사이에 방향성이 없는 선으로 연결된 그래프 |
| 방향그래프 | 연결선이 방향성르 지나는 그래프로 정점에 쌍으로 나타난 정점의 순서가 중요한 그래프 |
| 완전 그래프 | 그래프의 각 정점에서 다른 모든 정점을 연결하여 최대로 많은 간선 수를 가진 그래프 | 
| 가중 그래프 | 그래프의 정점을 연결하는 간선에 가중치를 할당한 그래프 |

- 그래프는 수행하는 기능이나 응용 방법에 따라 다양한 구현방법으로 메모리내에 표현됨.
 => 인접행렬: 순차 자료구조를 이용한 그래프 구현 방식으로 행렬에 대한 2차원 배열을 사용하여 그래프의 두 정점을 연결한 간선의 유무를 행렬로 저장하는 방식
 => 인접리스트: 연결 자료구조를 이용한 그래프 구현 방식. 각 정점에 대한 인접 정점들을 연결하여 만든 단순 연결리스트. 각 정점의 차수만큼 노드 연결하는 방식 

### 자료구조의 선택 기준 

* 자료의 처리시간
* 자료의 크기
* 자료의 활용 빈도
* 자료의 갱신 정도
* 프로그램의 용이성

### 자료구조의 활용

* 데이터의 정렬, 검색, 파일 편성 및 인덱스 등에서 주로 활용. 

1. 리스트: 배열의 구현, DBMS 인덱스 탐색이나 정렬
2. 스택: 이터럽트 처리, 재귀 프로그램 순서 제어, 서브루틴 복귀번지 저장, 후위 표기법 표현 수식 연산, 텍스트 에디터 Undo 기법
3. 큐: 운영체제의 작업 스케줄링, 대기 행렬의 처리, 비동기 데이터 교환 운용
4. 데크: 스택과 큐의 장점만 활용한 자료구조로 스택과 큐 관련 분야 활용
5. 트리: 탐색정렬 문제, 문법 파싱, 허프만 코드, 결정 트리 ,게임
6. 그래프: 컴퓨터 네트워크, 전기회로 분석, 이항관계, 연립방정식

## 알고리즘

### 개요

1. 정의: 문제 해결을 위한 일련의 절차. 문제 해결 방법 추상화 및 단계적 절차 논리적으로 기술해놓은 명세서
2. 알고리즘의 조건

| 조건 | 설명 |
| ---- | ---- |
| 입력 | 알고리즘 수행에 필요한 자료가 외부에서 0개 이상 입력으로 제공 |
| 출력 | 알고리즘 수행 후 하나 이상의 결과 출력 |
| 명확성 | 수행 작업 내용 순서를 나타내는 알고리즘의 각 처리 단계의 명령어들은 명확하게 명세 |
| 유한성 | 알고리즘은 수행 후 반드시 종료 |
| 효과성 | 모든 명령어들은 기본적이며 실행 가능해야 함. |

### 알고리즘 분석 기준

1. 정확성
2. 작업량
3. 기억 저장소 욕량
4. 최적성
5. 단순성

### 알고리즘 표현 방법

| 표현 방법 | 설명 |
| ---- | ---- |
| 자연어 기술 | 일상적으로 사용하는 말 |
| 순서도 표현 | FlowChart, NS 차트와 같은 그래픽적인 알고리즘으로 표현 |
| 의사코드 | 간략한 알고리즘을 프로그래밍 언어와 유사한 형태로 작성한 코드 |


### 알고리즘 성능 분석

* 실행헤 필요한 공간 측면에서 분석하는 공간 복잡도와 실행에 소요되는 시간 측면에서 분석하는 시간 복잡도를 추정하여 일반적인 평가를 내림

1. 공간 복잡도

* 알고리즘 실행 후 완료까지 필요한 총 저장공간
* 고정 공간량과 가변 공간량의 합으로 구함.
* 고정 공간량: 프로그램. 프로그램의 크기나 입출력 횟수에 상관없이 고정적으로 필요한 저장공간.
* 가변 공간량: 프로그램의 수행과정에서 사용하는 자료와 변수들을 저장하는 공간과 함수 실행에 관련된 정보 저장공간.

2. 시간 복잡도 

* 알고리즘을 프로그램으로 실행하여 완료하는 데 걸리는 시간으로 컴파일 시간과 실행시칸의 합으로 구한다.
* 컴파일 시간: 프로그램 특성가 관련이 적은 고정적인 시간. 일단 컴파일이 되면 일정하게 유지
* 실행시간: 프로그램의 실행시간. 컴퓨터 성능 등에 의존. 명령문의 실행 빈도수를 구하여 계산.

* 알고리즘 간의 비교 시에는 주로 실행 시간을 사용. 시간 복잡도로 나타낼 빅-오 표기법 사용

| 복잡도 표기 | 설명 |
| ---- | ---- |
| O(1) | 상수형. 입력 크기와 무관하게 바로 해를 구함. |
| O(logN) | 로그형. 입력자료를 나누어 그 중 하나만 처리. |
| O(N) | 선형. 입력자료를 차례로 하나씩 모두 처리 |
| O(NlogN) | 분할과 합병형. 자료를 분할하여 각각 처리하고 합병 |
| O(N^2) | 제곱형. 기본연산 loop 구조가 2중인 경우 |
| O(N^3) | 세제곱형. 기본연산 loop 구조가 3중인 경우 |
| O(2^n) | 지수형. 가능한 해결방법 모두를 다 검사하며 처리 |

### 정렬 알고리즘 

1. 정렬의 분류

* 내부 정렬: 소량의 데이터에 대해 주기억장치에 올려 정렬. 정렬 속도 빠름. 정렬 데이터 량 한정.
* 외부 정렬: 대량의 데이터에 대해 보조 기억장치에서 정렬. 대량의 데이터를 몇 개의 서브 파일로 나누어 내부 정렬 후. 보조기억장치에서 각 서브파일 병합. 속도가 매우 느림.

2. 내부 정렬 알고리즘 분류

* 삽입법: 삽입 정렬, 쉘 정렬
* 교환법: 선택 정렬, 퀵 정렬, 버블 정렬
* 선택법: 힙 정렬
* 병합법: 머지 정렬
* 분배법: 계수 정렬, 기수 정렬, 버킷 정렬

3. 내부정렬 알고리즘의 수행시간 비교

| 정렬 방법 | 설명 | 최악 수행시간 | 평균 수행 시간 | 최선 수행 시간 | 추가 메모리 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 삽입 정렬 | - 데이터가 정렬되어 있다고 가정하고 값을 해당 위치에 삽입하여 정렬하는 방법 | O(N^2) | O(N^2) | O(N) | X | 
| 쉘 정렬 | - 주어진 자료 리스트를 특정 매개변수 값의 길이를 갖는 서브파일로 쪼개서, 각 서브파일에서 삽입 정렬 수행 | O(Nlog2(N)) | O(N^1.5) | O(N) | X |
| 선택 정렬 | - 최소값을 찾아 왼쪽으로 이동시키는 데 데이터의 크기만큼 반복하여 정렬 | O(N^2) | O(N^2) | O(N^2) | X |
| 퀵 정렬 | - 분할 정복 방식으로 고안. 임의의 기준 선택 후 그 기준보다 작은 값을 왼쪽에 큰 값을 오른쪽에 위치시킴. 계속 반복 <br> - 재귀호출 사용 | O(N^2) | O(NlogN) | O(NlogN) | X |
| 버블 정렬 | -인접한 데이터 간에 교환이 계속해서 일어나면서 정렬이 이루어지는 방법 | O(N^2) | O(N^2) | O(N^2) | X |
| 힙 정렬 | -최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법 | O(NlogN) | O(NlogN) | O(NlogN) | X |
| 머지 정렬 | -분할정복방법 사용 하는데 데이터의 크기를 반으로 계속 나누고 이를 정렬하면서 다시 합치는 방법 | O(NlogN) | O(NlogN) | O(NlogN) | O |  
| 기수 정렬 | 데이터의 낮은 자리 수부터 비교하여 정렬해가는 방법 | O(dN) | O(dN) | O(dN) | O | 

4. 선택 정렬

* 가장 간단한 정렬 알고리즘. 배열 A[1..n]에서 가장 큰 원소를 차장 배열의 맨 끝자리에 있는 A[n]자리를 바꾸는 정렬 방법.

```
selectionSort(A[], n)
{
  for last <- n down to 2 {
    A[1..last] 중 가장 큰 수 A[k]를 찾는다.
    A[k] <-> A[last];
  }
}
```

* for 루프는 정렬할 배열의 크기를 하나씩 줄이는 역할로 맨 처음 배열의 크기가 n에서 시작하여 다음 루프에서는 n-1이 되고 지속적으로 작아지게 된다. 

5. 버블 정렬

* 선택 정렬처럼 제일 큰 원소를 끝자리로 옮기는 작업을 반복하지만, 제일 큰 원소를 오른쪽으로 옮길 때 왼쪽에 이웃한 수를 비교하면서 순서가 제대로 되어 있지 않으면 자리를 바꾸어 진행하는 정렬 알고리즘.

```
bubbleSort(A[], n)
{
  for last <- n downTo 2{
    for i <- 1 to last - 1
      if(A[i] > A[i+1]) then A[i] <-> A[i+1]
  }
}
```

### 검색 알고리즘

1. 개요

* 데이터 집합에서 원하는 항목을 효율적으로 찾는 기법.
* 정렬 여부에 따라 순차검색, 제어 검색으로 구분.
* 특정 함수에 따라 키 값을 계산하여 데이터를 검색하는 해싱.

2. 분류

* 선형 검색

- 선형 탐색

```
처음부터 마지막까지 순서대로 각 레코드를 비교하면서 찾아가는 방법. 
프로그램 작성 용이, 
파일 크기가 클수록 탐색 시간 증가, 
가장 간단하고 직접적인 검색 방법, 
평균비교횟수: (n+1)/2, 평균 검색시간: O(n)
```

* 제어 검색

- 이진탐색: 상한값과 하한값을 설정하고 그 중간값을 구한 후 키와 중간값을 계속 비교하면서 검색. 평균 검색시간 O(log2(N))
- 피보나치 탐색: 피보나치 순열을 이용하여 서브 파일을 형성해 가면서 검색하는 방법. 평균 검색시간 O(log2(N))
- 보간 탐색: 탐색 대상이 있을 것으로 예상되어지는 위치를 선택하여 찾아가는 방식으로 이후 그 위치에서 선형 탐색. 평균 검색시간 O(logN))
- 블록 탐색: 전체 데이터를 일정한 개수의 블록으로 구분하고 찾기를 원하는 데이터가 속한 블록을 결정한 후 해당 블록 내의 키 값을 순차적으로 검색. 효율적일 때는 N^(1/2), 평균적으로는 O(logN)
- 이진트리 탐색: 이진 트리를 이용하는 검색 방법. 평균적으로 삽입/검색/삭제 모두 O(logN)의 성능

* 해싱: 해싱함수를 이용하여 데이터가 저장되어 있는 주소를 직접 계산하여 찾아가는 검색방법. 삽입과 삭제가 빈번한 자료에 적합함.

### 그래프 탐색 알고리즘

1. 그래프 탐색

* 그래프의 가장 기본적인 연산으로 하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한 번씩 방문하여 처리하는 연산. 그래프 탐색 방법에는 dfs와 bfs가 있다.

2. 깊이 우선 탐색(dfs)

* 시작 정점의 한 방향으로 갈 수 있는 경로가 있는데까지 깊이 탐색해가다 더 이상 갈 곳이 없으면 마지막 갈림길 간선이 있는 정점으로 되돌아와 다른 방향의 간선으로 탐색을 계속 반복하여 목표 노드를 찾을 때까지 정점을 방문하는 방법
* 마지막 갈림길 간선의 정점으로 되돌아가 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택을 사용.

3. 너비 우선 탐색(bfs)

* 하나의 시작 정점을 방문한 후 인접한 노드를 먼저 탐색하는 방법으로 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 탐색 방법.
* 너비 우선 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 하고 방문한 노드들을 차례로 꺼낼 수 있는 자료 구조인 큐를 사용한다.

### 최소 신장 트리

1. 최소신장트리

* 신장트리는 무방향 가중치 그래프 내 모든 정점을 포함하고 서로 연결되어 있는 트리의 특수한 형태. 사이클 포함 X
* 신장 트리는 구성하는 가중치의 합이 최소인 신장 트리를 최소 신장 트리라고 함.
* 최소 신장 트리를 구현하는 대표적인 알고리즘은 크루스칼 알고리즘과 프림 알고리즘.

2. 크루스칼 

* 정점에 연결된 간선 가운데 가중치가 최소인 간선을 선택하고 추가된 간선이 사이클을 만드는 지 체크하는 방식으로 처리

[설명](https://chanhuiseok.github.io/posts/algo-33/)

3. 프림 알고리즘

* 분석대상 그래프에서 임의의 한 정점을 선택하여 각 반복과정마다 그때까지 구성된 최소 신장 트리 부분에 방문하지 않은 새로운 정점과 간선을 선택하여 확장해 나가는 방법.

[설명](https://www.weeklyps.com/entry/%ED%94%84%EB%A6%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Prims-algorithm)
