# 센서

## 출처

* https://www.acmicpc.net/problem/2212

## 문제

* 한국도로공사는 고속도로의 유비쿼터스화를 위해 고속도로 위에 N개의 센서를 설치하였다. 문제는 이 센서들이 수집한 자료들을 모으고 분석할 몇 개의 집중국을 세우는 일인데, 예산상의 문제로, 고속도로 위에 최대 K개의 집중국을 세울 수 있다고 한다.

* 각 집중국은 센서의 수신 가능 영역을 조절할 수 있다. 집중국의 수신 가능 영역은 고속도로 상에서 연결된 구간으로 나타나게 된다. N개의 센서가 적어도 하나의 집중국과는 통신이 가능해야 하며, 집중국의 유지비 문제로 인해 각 집중국의 수신 가능 영역의 길이의 합을 최소화해야 한다.

* 편의를 위해 고속도로는 평면상의 직선이라고 가정하고, 센서들은 이 직선 위의 한 기점인 원점으로부터의 정수 거리의 위치에 놓여 있다고 하자. 따라서, 각 센서의 좌표는 정수 하나로 표현된다. 이 상황에서 각 집중국의 수신 가능영역의 거리의 합의 최솟값을 구하는 프로그램을 작성하시오. 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.
 
## 입력

* 첫째 줄에 센서의 개수 N(1 ≤ N ≤ 10,000), 둘째 줄에 집중국의 개수 K(1 ≤ K ≤ 1000)가 주어진다. 셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 있으며, 좌표의 절댓값은 1,000,000 이하이다.

## 출력

* 첫째 줄에 문제에서 설명한 최대 K개의 집중국의 수신 가능 영역의 길이의 합의 최솟값을 출력한다.

## 입력 예제 1

```
6
2
1 6 9 3 6 7
```

## 출력 예제 1

```
5
```

## 입력 예제 2

```
10
5
20 3 14 6 7 8 18 10 12 15
```

## 출력 예제 2

```
7
```

## 풀이

### 문제 정의

* N개의 센서 위치가 주어지고, 최대 K개의 집중국(기지국) 을 설치할 수 있다.

* 집중국의 수신 영역은 연속 구간이다.

* 모든 센서가 적어도 하나의 집중국에 포함되어야 하며, 집중국들의 수신 가능 구간 길이 합을 최소로 만들어야 한다.

* 즉 센서 배열을 K개의 그룹으로 나누어 각 그룹 내의 거리 합(구간 길이)을 최소로 하는 문제.

### 해결 아이디어

* 그리디 알고리즘을 활용하여 풀이한다. 순서는 아래와 같다.

1. 센서 위치를 오름차순 정렬한다.
2. 인접한 센서 간의 거리 차이를 모두 구한다
3. 이 거리차이를 내림차순 정렬한다.
4. 가장 큰 K-1개의 거리를 끊는 지점으로 선택하면 → 총 K개의 그룹으로 나누는 것과 같다.
5. 나머지 거리들을 더하면 최종 최소 구간 합이 된다.

## 소스코드

```kotlin
package greedy

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer
import java.util.Collections
import java.util.ArrayList

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))
    val n = br.readLine().trim().toInt()
    val k = br.readLine().trim().toInt()

    val st = StringTokenizer(br.readLine())
    val sensors = ArrayList<Int>()
    repeat(n) {
        sensors.add(st.nextToken().toInt())
    }

    // 센서 위치 정렬
    sensors.sort()

    // 센서 간 거리 리스트
    val diffs = ArrayList<Int>()
    for (i in 0 until n - 1) {
        diffs.add(sensors[i + 1] - sensors[i])
    }

    // K >= N 이면 모든 센서에 집중국 설치 가능 -> 길이 합 = 0
    if (k >= n) {
        println(0)
        return
    }

    // 거리 차 내림차순 정렬
    diffs.sortWith(Collections.reverseOrder())

    // 가장 큰 K-1개 거리 제외하고 나머지 모두 더하기
    var answer = 0
    for (i in (k - 1) until diffs.size) {
        answer += diffs[i]
    }

    println(answer)
}
```
