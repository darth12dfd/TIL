# 과제

## 출처

* https://www.acmicpc.net/problem/13904

## 문제

* 웅찬이는 과제가 많다. 하루에 한 과제를 끝낼 수 있는데, 과제마다 마감일이 있으므로 모든 과제를 끝내지 못할 수도 있다. 과제마다 끝냈을 때 얻을 수 있는 점수가 있는데, 마감일이 지난 과제는 점수를 받을 수 없다.

* 웅찬이는 가장 점수를 많이 받을 수 있도록 과제를 수행하고 싶다. 웅찬이를 도와 얻을 수 있는 점수의 최댓값을 구하시오.

## 입력

* 첫 줄에 정수 N (1 ≤ N ≤ 1,000)이 주어진다.

* 다음 줄부터 N개의 줄에는 각각 두 정수 d (1 ≤ d ≤ 1,000)와 w (1 ≤ w ≤ 100)가 주어진다. d는 과제 마감일까지 남은 일수를 의미하며, w는 과제의 점수를 의미한다.

## 출력

* 얻을 수 있는 점수의 최댓값을 출력한다.

## 입력 예제 1

```
7
4 60
4 40
1 20
2 50
3 30
4 10
6 5
```

## 출 예제 1

```
185
```

## 풀이

* 가장 큰 점수를 얻기 위해, 마감이 늦은 날부터 가능한 가장 높은 점수를 가진 과제를 선택

* 날짜별로 어떤 과제를 할 것인지 결정해야 하고, 최적의 결과는 높은 점수의 과제를 최대한 많이 수행하는 것. 하지만 단순히 점수가 높은 것만 골라서는 안됨. 과제마다 마감일(d)이 있기 때문.

* 그런고로 그리디 알고리즘을 해야함

### 전제

* 하나의 날짜에 수업은 1개만 가능 → 시간 제약 존재

* 가능한 경우를 효율적으로 골라야 함

### 순서

* 과제들을 마감일 순으로 정렬

* 가장 큰 날짜부터 거꾸로 처리한다

* 우선순위 큐를 사용한다 (최대 힙). 각 날짜에서 선택할 수 있는 과제 중 현재 가능한 가장 큰 점수를 선택한다.

## 소스코드

```kotlin
package greedy

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer
import java.util.PriorityQueue
import java.util.Collections

fun main() = with(BufferedReader(InputStreamReader(System.`in`))) {
    val n = readLine().toInt()

    val arr = Array(n) { IntArray(2) }
    var maxDay = 0

    for (i in 0 until n) {
        val st = StringTokenizer(readLine())
        val d = st.nextToken().toInt()
        val s = st.nextToken().toInt()
        arr[i][0] = d
        arr[i][1] = s
        if (d > maxDay) maxDay = d
    }

    // 마감일 오름차순 정렬
    arr.sortBy { it[0] }

    val pq = PriorityQueue<Int>(Collections.reverseOrder())
    var idx = n - 1
    var result = 0

    // 가장 늦은 날부터 역순으로 확인
    for (day in maxDay downTo 1) {
        while (idx >= 0 && arr[idx][0] >= day) {
            pq.add(arr[idx][1])
            idx--
        }
        if (pq.isNotEmpty()) {
            result += pq.poll()
        }
    }

    println(result)
}

```
