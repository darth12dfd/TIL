# A와 B

## 출처

* https://www.acmicpc.net/problem/12904

## 문제

* 수빈이는 A와 B로만 이루어진 영어 단어가 존재한다는 사실에 놀랐다. 대표적인 예로 AB (Abdominal의 약자), BAA (양의 울음 소리), AA (용암의 종류), ABBA (스웨덴 팝 그룹)이 있다.

* 이런 사실에 놀란 수빈이는 간단한 게임을 만들기로 했다. 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다.

    - 문자열의 뒤에 A를 추가한다.
      
    - 문자열을 뒤집고 뒤에 B를 추가한다.
      
* 주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오. 

## 입력

* 첫째 줄에 S가 둘째 줄에 T가 주어진다. (1 ≤ S의 길이 ≤ 999, 2 ≤ T의 길이 ≤ 1000, S의 길이 < T의 길이)

## 출력

* S를 T로 바꿀 수 있으면 1을 없으면 0을 출력한다.

## 입력 예제 1

```
B
ABBA
```

## 출력 예제 1

```
1
```

## 입력 예제 2

```
AB
ABB
```

## 출력 예제 2

```
0
```

## 풀이

* 문자열 S를 시작으로 아래 두 연산만 사용해서 T를 만들 수 있는지 판단하는 문제

* 허용 연산:

    - 문자열 뒤에 A 추가

    - 문자열 뒤에 B 추가 후 전체 뒤집기
 
* 이때 이걸 그대로 하면 경우의수가 2가지씩 발생. => 그대로 전부 다하면 문자열 길어질 때 시간초과 발생함

* 따라서 이걸 역방향으로 풀어야됨. 이유는 T의 마지막 문자만 보면 이전 상태가 유일하게 정해지기 때문임

| 현재 T의 마지막 문자 | 되돌리는 연산     |
| ------------ | ----------- |
| `A`          | 그냥 제거       |
| `B`          | 제거 후 전체 뒤집기 |

* 위의 두 과정을 반복하면 S와 길이가 같아지고 그때 S와 동일한 문자열인지 확인 가능함

* 즉, 지금 상태에서 바로 이전으로 갈 때 최선의 선택을 하는 것이므로 그리디 알고리즘 문제에 해당하여 풀어주면 됨.


## 소스코드

```kotlin
package greedy

import java.io.BufferedReader
import java.io.InputStreamReader

fun main() = with(BufferedReader(InputStreamReader(System.`in`))) {
    val s = readLine()!!
    var t = readLine()!!

    // T 문자열을 S 길이와 같아질 때까지 줄여간다
    while (t.length > s.length) {
        val last = t.last()  // 마지막 문자 확인
        t = t.dropLast(1)     // 끝 문자 제거

        // 만약 제거한 문자가 B였다면 남은 문자열을 뒤집는다
        if (last == 'B') {
            t = t.reversed()
        }
    }

    // 최종적으로 같으면 1, 아니면 0
    println(if (t == s) 1 else 0)
}

```
