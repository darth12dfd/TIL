# 레벨 햄버거

## 출처

* https://www.acmicpc.net/problem/16974

## 문제

* 상근날드에서 오랜만에 새로운 햄버거를 출시했다. 바로 레벨-L 버거이다. 레벨-L 버거는 다음과 같이 만든다.

```
레벨-0 버거는 패티만으로 이루어져 있다.
레벨-L 버거는 햄버거번, 레벨-(L-1) 버거, 패티, 레벨-(L-1)버거, 햄버거번으로 이루어져 있다. (L ≥ 1)
```
* 예를 들어, 레벨-1 버거는 'BPPPB', 레벨-2 버거는 'BBPPPBPBPPPBB'와 같이 생겼다. (B는 햄버거번, P는 패티)

* 상도가 상근날드에 방문해서 레벨-N 버거를 시켰다. 상도가 햄버거의 아래 X장을 먹었을 때, 먹은 패티는 몇 장일까? 한 장은 햄버거번 또는 패티 한 장이다.

## 입력

* 첫째 줄에 N과 X가 주어진다.

## 출력

* 첫째 줄에 상도가 먹은 패티의 수를 출력한다.

## 제한

* 1 ≤ N ≤ 50
* 
* 1 ≤ X ≤ 레벨-N 버거에 있는 레이어의 수

## 입력 예제 1

```
2 7
```

## 출력 예제 1

```
4
```

## 입력 예제 2

```
1 1
```

## 출력 예제 2

```
0
```

## 입력 예제 3

```
50 4321098765432109
```

## 출력 예제 3

```
2160549382716056
```

## 풒이

* 분할 정복 + 재귀로 큰 레벨의 햄버거에 대해 아래에서 X장까지 먹었을 때 먹은 패티 수를 효율적으로 구하는 문제

* 레벨-L 햄버거는:

```
레벨-0 : P
레벨-L : B  + (L-1 버거) + P + (L-1 버거) + B   (L >= 1)
```
B = 빵 (패티 X)
P = 패티

* 레벨 N 버거를 아래에서부터 X장 먹었을 때 먹은 패티 개수를 출력

*  N 최대 50, X는 햄버거 길이 범위 내. 

* 그냥 문자열을 만들면 크기가 엄청나기 때문에 길이/패티 개수만 계산하고 재귀로 처리

### 햄버거 구성

* 레벨 L 버거: B | (레벨 L-1 버거) | P | (레벨 L-1 버거) | B

* 전체 길이: 2*burgerLen[L-1] + 3

* 패티 총 개수: 2*pattyCnt[L-1] + 1

### 분할 정복 케이스

* 먹은 장 수 X에 따라 경우를 나누기

| 위치	| 처리 |
| ---- | ---- |
| X == 1 | 빵 → 패티 0 |
| X ≤ leftLen+1 |	왼쪽 작은 햄버거 재귀 |
| X == midPos	| 왼쪽 패티 개수 + 1 |
| X ≤ midPos+leftLen	| 왼쪽 전체 + 중앙 + 오른쪽 일부 재귀 | 
|  그 외	| 전체 패티 수 |

## 소스코드

```kotlin
package divideandconquer

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer
import kotlin.math.min

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))
    val st = StringTokenizer(br.readLine())
    val N = st.nextToken().toInt()
    var X = st.nextToken().toLong()

    // burgerLen[i]: i레벨 햄버거 전체 길이
    // pattyCnt[i]: i레벨 햄버거 패티 개수
    val burgerLen = LongArray(51)
    val pattyCnt = LongArray(51)

    // 레벨0은 패티 1개, 길이 1
    burgerLen[0] = 1L
    pattyCnt[0] = 1L

    for (i in 1..N) {
        // 빵 + (i-1) + 패티 + (i-1) + 빵 = 2*burgerLen[i-1] + 3
        burgerLen[i] = burgerLen[i - 1] * 2L + 3L
        // 패티는 양쪽 i-1 + 가운데 1
        pattyCnt[i] = pattyCnt[i - 1] * 2L + 1L
    }

    fun solve(level: Int, x: Long): Long {
        if (level == 0) { // 레벨0이면 x<=1 이니까 x==1이면 1, x==0이면 0
            return if (x <= 0L) 0L else 1L
        }
        if (x <= 0L) return 0L

        val leftLen = burgerLen[level - 1]
        val midPos = leftLen + 2L // 가운데 패티 위치

        return when {
            x == 1L -> 0L // 첫 빵
            x <= leftLen + 1L -> solve(level - 1, x - 1L) // 왼쪽 버거
            x == midPos -> pattyCnt[level - 1] + 1L // 왼쪽 전체 패티 + 중앙 패티
            x <= midPos + leftLen -> {
                // 왼쪽 전체 패티 + 중앙 패티 + 오른쪽 일부
                pattyCnt[level - 1] + 1L + solve(level - 1, x - midPos)
            }
            else -> pattyCnt[level] // 다 먹는 상황
        }
    }

    println(solve(N, X))
}

```

