# 피보나치 수 3

## 출처

* https://www.acmicpc.net/problem/2749

## 문제

* 피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.

* 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.

* n=17일때 까지 피보나치 수를 써보면 다음과 같다.

```
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597
```

* n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.

## 출력

* 첫째 줄에 n번째 피보나치 수를 1,000,000으로 나눈 나머지를 출력한다.

## 입력 예제 1

```1000```

## 출력 예제 1

```228875```

## 풀이

* 일반적인 피보나치 수 풀이법을 사용하면 기대한 값과는 다른 값이 나온다.

* 출력 부분에서 힌트를 얻을 수 있다. n번째 피보나치 수를 특정 수로 나눈 나머지를 출력하는 것. 즉 피사노 주기를 이용하는 것임을 알 수 있다.

* 피사노 수열 중에서 정수 k가 10^n일 때, f(10^n)=15*10^(n-1) 임을 알 수 있다. 이때, 함수 f는 피보나치 수열을 k로 나눈 나머지의 주기를 구하는 함수이다.

* 즉, 여기서는 k값이 10^6이 되므로 f(k)=15*10^5 즉, 150만이 된다. 달리말하면 피사노 주기가 150만이라는 의미이다.

* 즉, 어떤 수가 입력되도 해당 피보나치수의 나머지는 150만을 주기로 이뤄지므로, 만약 입력받은 n값이 150만보다 큰 경우에는 n을 150만으로 나눈 숫자의 위치에 있는 값과 동일하다.

* 피사노 주기만큼의 크기를 가진 Long 배열을 만들고 0번째와 1번째는 각각 0과 1로 저장한다. 그리고, 2부터 피사노 주기만큼의 숫자까지 다음과 같은 식을 반복해주면 된다.

```arr[i]=(arr[i-1]+arr[i-2])%1000000```

## 소스코드

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader

fun main()=with(BufferedReader(InputStreamReader(System.`in`))){
    var n=readLine().toLong()

    var pisano=1500000
    var array=LongArray(pisano,{0L})

    array[0]=0L
    array[1]=1L
    for(i in 2 until pisano){
        array[i]=(array[i-1]+array[i-2])%1000000
    }

    if(n>=pisano){
        n%=pisano
    }
    println(array[n.toInt()])
    close()
}
```
