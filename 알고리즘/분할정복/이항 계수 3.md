# 이항 계수 3

## 출처

* https://www.acmicpc.net/problem/11401

## 문제

* 자연수 
\(N\)과 정수 
\(K\)가 주어졌을 때 이항 계수 
$\binom{n}{k}$를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 
\(N\)과 
\(K\)가 주어진다. (1 ≤ 
\(N\) ≤ 4,000,000, 0 ≤ 
\(K\) ≤ 
\(N\))

## 출력

* $\binom{n}{k}$를 1,000,000,007로 나눈 나머지를 출력한다.

## 입력 예제 1

```
5 2
```

## 출력 예제 1

```
10
```

## 풀이

* nCk 계산 (조합)

* n, k 최대 1,000,000

* 결과는 **1,000,000,007 (MOD)**로 출력해야 함

* 단순 반복으로는 시간 초과 → 팩토리얼 + 모듈러 역원 + 빠른 거듭제곱(Fermat) 이용(코드에서 설명)

## 소스코드

```kotlin
package divideandconquer

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer

const val MOD = 1_000_000_007L

fun main() {
    val reader = BufferedReader(InputStreamReader(System.`in`))
    val st = StringTokenizer(reader.readLine())
    val n = st.nextToken().toInt()
    val k = st.nextToken().toInt()

    // 팩토리얼 테이블 미리 계산
    val fact = LongArray(n + 1)
    fact[0] = 1L
    for (i in 1..n) {
        fact[i] = (fact[i - 1] * i) % MOD
    }

    // nCk = n! * inv(k!) * inv((n-k)!)
    val numerator = fact[n]
    val denom = (fact[k] * fact[n - k]) % MOD

    val answer = (numerator * modInverse(denom, MOD - 2)) % MOD
    println(answer)
}

// 빠른 거듭제곱 (mod exp)
fun modInverse(x: Long, exponent: Long): Long {
    var result = 1L
    var base = x % MOD
    var exp = exponent

    while (exp > 0) {
        if (exp and 1L == 1L) {
            result = (result * base) % MOD
        }
        base = (base * base) % MOD
        exp = exp shr 1
    }
    return result
}

```
