# A와 B 2

## 출처

* https://www.acmicpc.net/problem/12919

## 문제

* 수빈이는 A와 B로만 이루어진 영어 단어 존재한다는 사실에 놀랐다. 대표적인 예로 AB (Abdominal의 약자), BAA (양의 울음 소리), AA (용암의 종류), ABBA (스웨덴 팝 그룹)이 있다.

* 이런 사실에 놀란 수빈이는 간단한 게임을 만들기로 했다. 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다.

```
문자열의 뒤에 A를 추가한다.
문자열의 뒤에 B를 추가하고 문자열을 뒤집는다.
```

* 주어진 조건을 이용해서 S를 T로 만들 수 있는지 없는지 알아내는 프로그램을 작성하시오. 

## 입력

* 첫째 줄에 S가 둘째 줄에 T가 주어진다. (1 ≤ S의 길이 ≤ 49, 2 ≤ T의 길이 ≤ 50, S의 길이 < T의 길이)

## 출력

* S를 T로 바꿀 수 있으면 1을 없으면 0을 출력한다.

## 입력 예제 1

```
A
BABA
```

## 출력 예제 1

```
1
```

## 입력 예제 2

```
BAAAAABAA
BAABAAAAAB
```

## 출력 예제 2

```
1
```

## 입력 예제 3

```
A
ABBA
```

## 출력 예제 3

```
0
```

## 풀이

* 정방향으로 S에서 T를 만드는 방법과 반대로 T에서 S를 만드는 방법이 존재
    1. S => T로 만들기
        - 정방향일때 가능한 연산
              1. X → X + "A"
              2. X → reverse(X + "B")
                - : 이 경로가 맞는지 끝에 가서야 확인 가능하며 틀렸을때 돌아올 분기가 너무 많음. 거거에 아예 안되는 것들은 가지치기도 안됨
                   => 브루트포스 연산하다가 터질 수가 있음
    2. T => S로 만들기
        - 현재 문자열이 cur일 때 가능한 경우는 딱 두 개뿐:
            연산 1. 끝이 A인 경우 => 끝A 빼기 {...A → ..}
            
            연산 2. 앞이 B인 경우 => 끝B 빼고 문자열 뒤집기 { B... → reverse(...) }
            
            - 중요한 점: 조건을 만족할 때만 연산 가능. 무조건 가능한 게 아님(역방향이므로 ㅇㅇ)
            
              1. 선택지가 자동으로 줄어듦.
                 - 끝이 A가 아니면 연산 1 불가
                 - 앞이 B가 아니면 연산 2 불가
                 
              2. 가지치기도 쉬움( 이를테면 ABB가 나와버리면 연산 1,2 둘다 못하므로 아예 불가능함)
              
    그런고로 S => T로 만들기보다는 T => S로 만드는게 훨씬 편안함

## 소스코드

```kotlin
package bruteforce

import java.io.BufferedReader
import java.io.InputStreamReader

/*
    정방향으로 S에서 T를 만드는 방법과 반대로 T에서 S를 만드는 방법이 존재
    S => T로 만들기
        정방향일때 가능한 연산
            X → X + "A"
            X → reverse(X + "B")
        : 이 경로가 맞는지 끝에 가서야 확인 가능하며 틀렸을때 돌아올 분기가 너무 많음. 거거에 아예 안되는 것들은 가지치기도 안됨
         => 브루트포스 연산하다가 터질 수가 있음
    T => S로 만들기
        : 현재 문자열이 cur일 때 가능한 경우는 딱 두 개뿐:
            연산 1. 끝이 A인 경우 => 끝A 빼기 {...A → ..}.
            연산 2. 앞이 B인 경우 => 끝B 빼고 문자열 뒤집기 { B... → reverse(...) }
            중요한 점: 조건을 만족할 때만 연산 가능. 무조건 가능한 게 아님(역방향이므로 ㅇㅇ)
            1. 선택지가 자동으로 줄어듦.
                끝이 A가 아니면 연산 1 불가
                앞이 B가 아니면 연산 2 불가
            2. 가지치기도 쉬움( 이를테면 ABB가 나와버리면 연산 1,2 둘다 못하므로 아예 불가능함)
      => 그런고로 S => T로 만들기보다는 T => S로 만드는게 훨씬 편안함
 */

/*
    재귀를 하는데 있어서 어떤 식으로 하는게 좋은가 => 재귀함수를 하나 만들어서 하면 좋음.
 */

private lateinit var S: String
private var answer = 0//전역으로 정답 값을 저장해둠
private val visited = HashSet<String>()//방문한 배열 저장할 해시

fun main() = with(BufferedReader(InputStreamReader(System.`in`))){
    S = readLine()//목표 문자열
    val T = readLine()//시작 문자열
    
    // T => S로 줄이기
    recursive(T)
    println(answer)
    close()
}

//재귀함수
fun recursive(cur:String){
    //정답이 1이면 그대로 종료
    if(answer == 1){
        return
    }
    //재귀 돌린 배열이 목표 배열의 길이와 같으면 함수 종료(만약 문자열도 동일하면 정답 값 1로 수정)
    if(cur.length == S.length){
        if(cur == S){
            answer = 1
        }
        return
    }

    //이미 방문했던 배열이면 함수 종료
    if(!visited.add(cur)){
        return
    }

    //역연산 1: 끝이 A인 경우, 역으로 마지막 A를 제거 가능
    if(cur.last() == 'A'){
        recursive(cur.dropLast(1))//마지막 녀석을 자르고 재귀를 돌림
    }


    //역연산 2: 앞이 B인 경우, 역으로 맨 앞 B 제거 후 다시 뒤집기
    if(cur.first() == 'B'){
        recursive(cur.drop(1).reversed())//맨 앞 B 자르고 문자열 뒤집은 뒤에 재귀 돌림
    }

    return
}
```
