# 별 찍기

## 출처

* https://www.acmicpc.net/problem/2447

## 문제

* 재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.
크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.
```
***
* *
***
```

* N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.

## 입력

* 첫째 줄에 N이 주어진다. N은 3의 거듭제곱이다. 즉 어떤 정수 k에 대해 N=3^k이며, 이때 1 ≤ k < 8이다.

## 출력

* 첫째 줄부터 N번째 줄까지 별을 출력한다.

## 입력 예제

```27```

## 출력 예제

```
***************************
* ** ** ** ** ** ** ** ** *
***************************
***   ******   ******   ***
* *   * ** *   * ** *   * *
***   ******   ******   ***
***************************
* ** ** ** ** ** ** ** ** *
***************************
*********         *********
* ** ** *         * ** ** *
*********         *********
***   ***         ***   ***
* *   * *         * *   * *
***   ***         ***   ***
*********         *********
* ** ** *         * ** ** *
*********         *********
***************************
* ** ** ** ** ** ** ** ** *
***************************
***   ******   ******   ***
* *   * ** *   * ** *   * *
***   ******   ******   ***
***************************
* ** ** ** ** ** ** ** ** *
***************************
```

## 풀이

* 별을 찍어야 되는 칸을 블록으로 가정하자. 27이라는 숫자가 입력되었을 때 27x27 크기의 행렬이 생성되게 된다. 이 행렬은 9*9 행렬 블록을 3*3 형태로 나열한 것과 동일하다. 자연스레 9*9 행렬도 3*3 행렬 블록을 3*3 형태로 나열한 것과 동일하며 3*3 행렬 블록도 1*1 행렬 블록 즉, 칸 하나를 3*3 형태로 나타낸 것과 동일히다.

* 이 때, 27*27 행렬 블록,9*9,3*3 행렬 블록 모두 가운데 칸은 빈 칸으로 놔둬야 한다. 이를 행렬의 형태로 생각해 보면, 5번째로 호출되는 블록은 무조건 빈칸이 된다는 이야기와 동일하다.

* 이를 위해 재귀함수를 전달할 때, isBlank라는 boolean타입 변수를 전달하기로 한다. 만약 해당 블록이 빈칸으로 채워져야 한다면, 해당 블록의 시작 위치에서 부터 해당 블록의 사이즈 만큼을 빈칸으로 채워야 한다.

* 결과적으로 이 블록은 1*1의 단위행렬 형태로 쪼개져야 한다. 이를 위해, 블록을 채울 이차원 배열과 이차원 배열의 x,y인덱스 역시 전달해줘야 한다. 그리고 재귀함수를 호출할 때마다 블록의 사이즈를 3 나눠서 그 사이즈가 1이 됬을 경우에, 1*1 블록을 별로 채우면 된다.

* 만약 입력받은 블록의 사이즈가 1보다 큰 경우, 그, 블록의 사이즈 만큼 반복문을 돌리고, 5번째로 반복문을 돌렸을 경우에는, isBlank 변수를 true로 해서 빈칸으로 채우는 재귀함수를 호출하고 그 외의 경우는 isBlank변수를 false로 해서 별을 채우는 재귀함수를 호출한다. 참고로 해당 재귀함수를 호출할 때, 블록의 사이즈를 3 만큼 나눠서 호출한다.

* 즉, 3의 배수의 크기를 가진 이차원 블록을 낱개로 나눠서 그 풀이를 더해나가는 분할정복 알고리즘 문제이다.

## 소스코드
```kotlin
import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.InputStreamReader
import java.io.OutputStreamWriter

fun main()=with(BufferedReader(InputStreamReader(System.`in`))){
    val number=readLine().toInt()
    val bw=BufferedWriter(OutputStreamWriter(System.`out`))

    var arr=Array(number,{CharArray(number,{' '})})//별들을 저장할 배열
    recursion(0,0,number,arr,false)//재귀함수 호출

    
    //배열을 출력
    for(i in 0 until number){
        for(j in 0 until number){
            bw.write("${arr[i][j]}")
        }
        bw.write("\n")
    }
    bw.flush()
    bw.close()
    close()
}


fun recursion(x:Int,y:Int,num:Int,array:Array<CharArray>,isBlank:Boolean):Unit{
    //만약 해당 배열의 칸에 빈칸이 들어가야 하는 경우
    if(isBlank){
        //해당 칸에서 해당 블록의 사이즈 만큼 공백으로 채운다.
        for(i in x until x+num){
            for(j in y until y+num){
                array[i][j]=' '
            }
        }
        return//아래의 내용은 실행하지 않고 함수를 리턴한다.
    }
    //만약 쪼갠 배열의 크기가 1인 경우 *을 해당 배열 칸에 저장한다.
    if(num==1){
        array[x][y]='*'
        return
    }
    val size=num/3//블록의 사이즈
    var count=0//해당 블록이 몇번 째 블록인지를 저장할 변수
    for(i in x until x+num step size){
        for(j in y until y+num step size){
            count++
            //해당 블록이 num 크기 블록 들 중 5 번째 배열인 경우 isBlank를 true 로 설정하고 재귀함수 호출
            if(count==5){
                recursion(i,j,size,array,true)
            }
            else{
                recursion(i,j,size,array,false)
            }
        }
    }
}
```
