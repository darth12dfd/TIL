# 하노이 탑

## 출처

* https://www.acmicpc.net/problem/1914

## 문제

* 세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.

    1. 한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
    2. 쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.

* 이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.

* 아래 그림은 원판이 5개인 경우의 예시이다.

<img width="1429" height="289" alt="image" src="https://github.com/user-attachments/assets/79a97e09-ac62-4ba4-a16a-800ac3e09605" />


## 입력

* 첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 100)이 주어진다.

## 출력

* 첫째 줄에 옮긴 횟수 K를 출력한다.

* N이 20 이하인 입력에 대해서는 두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다. N이 20보다 큰 경우에는 과정은 출력할 필요가 없다.

## 입력 예제 1 

```
3
```

## 출력 예제 1

```
7
1 3
1 2
3 2
1 3
2 1
2 3
1 3
```

## 풀이

* 하노이 탑에서 움직인 횟수와 그 움직인 내용을 출력하는 문제. 이 두가지를 출력하는 걸 목표로 한다.

* 우선 하노이 탑에서의 이동횟수에 대한 점화식은 아래와 같다

    ```
    dp[1] = 1
    dp[2] = 3
    dp[3] = 7
    dp[4] = 15
    ...
    dp[n] = 2^n - 1
    => 하노이 함수 hanoi(n) = 2^n-1
    ```

* 다음은 하노이탑에서의 실제 움직이는 과정은 아래와 같다. 보다시피 재귀함수가 사용되며 n이 0이 되기 전까지 재귀를 반복한다

```
실제 경로 출력
    hanoi(n, from, via, to)
        1. n-1개를 from → via (to를 보조)(위에꺼들 다 두번째 칸으로)
        2. 1개를 from → to(마지막 하나를 세번째 칸으로)
        3. n-1개를 via → to (from을 보조)(나머지 2번째 칸에 있는 것들 3번째 칸으로)
        4. n이 0개 될때까지 반복
```


## 풀이

* 하노이 탑에서 움직인 횟수와 그 움직인 내용을 출력하는 문제. 이 두가지를 출력하는 걸 목표로 한다.

* 우선 하노이 탑에서의 이동횟수에 대한 점화식은 아래와 같다

    ```
    dp[1] = 1
    dp[2] = 3
    dp[3] = 7
    dp[4] = 15
    ...
    dp[n] = 2^n - 1
    => 하노이 함수 hanoi(n) = 2^n-1
    ```

* 다음은 하노이탑에서의 실제 움직이는 과정은 아래와 같다. 보다시피 재귀함수가 사용되며 n이 0이 되기 전까지 재귀를 반복한다

```
실제 경로 출력
    hanoi(n, from, via, to)
        1. n-1개를 from → via (to를 보조)(위에꺼들 다 두번째 칸으로)
        2. 1개를 from → to(마지막 하나를 세번째 칸으로)
        3. n-1개를 via → to (from을 보조)(나머지 2번째 칸에 있는 것들 3번째 칸으로)
        4. n이 0개 될때까지 반복
```
    
## 소스코드

```kotlin
package recursive

/*
    점화식은 아래와 같다
    dp[1] = 1
    dp[2] = 3
    dp[3] = 7
    dp[4] = 15
    ...
    dp[n] = 2^n - 1
    => 하노이 함수 hanoi(n) = 2^n-1
 */

/*
    실제 경로 출력
    hanoi(n, from, via, to)
        1. n-1개를 from → via (to를 보조)(위에꺼들 다 두번째 칸으로)
        2. 1개를 from → to(마지막 하나를 세번째 칸으로)
        3. n-1개를 via → to (from을 보조)(나머지 2번째 칸에 있는 것들 3번째 칸으로)
        4. n이 0개 될때까지 반복
 */

import java.math.BigInteger
import java.lang.StringBuilder

// 출력이 매우 많아질 수 있으므로 StringBuilder 사용
private val sb = StringBuilder()

fun main() {
    // 원판 개수 입력
    val n = readLine()!!.trim().toInt()

    /* -------------------------------------------------
     * 최소 이동 횟수 계산
     * 하노이 탑의 최소 이동 횟수 = 2^n - 1
     * n이 최대 100이므로 BigInteger 사용
     * ------------------------------------------------- */
    val two = BigInteger("2")
    val moveCount = two.pow(n).subtract(BigInteger.ONE)

    // 이동 횟수 출력
    sb.append(moveCount).append('\n')

    /* -------------------------------------------------
     * 이동 과정 출력
     * 문제 조건:
     *   - n <= 20 일 때만 이동 과정을 출력
     * ------------------------------------------------- */
    if (n <= 20) {
        hanoi(n, 1, 2, 3)
    }

    // 최종 출력
    print(sb.toString())
}

/**
 * 하노이 탑 재귀 함수
 *
 * @param n    옮길 원판의 개수
 * @param from 시작 기둥(1번 기둥)
 * @param via  보조 기둥(2번 기둥)
 * @param to   도착 기둥(3번 기둥)
 */
private fun hanoi(n: Int, from: Int, via: Int, to: Int) {
    // 원판이 없으면 종료
    if (n == 0) return

    // 1️⃣ n-1개를 시작 기둥(from) → 보조 기둥(via)으로 이동
    // 이때 도착 기둥(to)을 임시 보조로 사용
    hanoi(n - 1, from, to, via)

    // 2️⃣ 가장 큰 원판 1개를 from → to 로 이동
    sb.append(from).append(' ').append(to).append('\n')

    // 3️⃣ n-1개를 보조 기둥(via) → 도착 기둥(to)으로 이동
    // 이때 시작 기둥(from)을 임시 보조로 사용
    hanoi(n - 1, via, from, to)
}
```
