# 네트워크 연결

## 출처

* https://www.acmicpc.net/problem/1922

## 문제

* 도현이는 컴퓨터와 컴퓨터를 모두 연결하는 네트워크를 구축하려 한다. 하지만 아쉽게도 허브가 있지 않아 컴퓨터와 컴퓨터를 직접 연결하여야 한다. 그런데 모두가 자료를 공유하기 위해서는 모든 컴퓨터가 연결이 되어 있어야 한다. (a와 b가 연결이 되어 있다는 말은 a에서 b로의 경로가 존재한다는 것을 의미한다. a에서 b를 연결하는 선이 있고, b와 c를 연결하는 선이 있으면 a와 c는 연결이 되어 있다.)

* 그런데 이왕이면 컴퓨터를 연결하는 비용을 최소로 하여야 컴퓨터를 연결하는 비용 외에 다른 곳에 돈을 더 쓸 수 있을 것이다. 이제 각 컴퓨터를 연결하는데 필요한 비용이 주어졌을 때 모든 컴퓨터를 연결하는데 필요한 최소비용을 출력하라. 모든 컴퓨터를 연결할 수 없는 경우는 없다.

## 입력

* 첫째 줄에 컴퓨터의 수 N (1 ≤ N ≤ 1000)가 주어진다.

* 둘째 줄에는 연결할 수 있는 선의 수 M (1 ≤ M ≤ 100,000)가 주어진다.

* 셋째 줄부터 M+2번째 줄까지 총 M개의 줄에 각 컴퓨터를 연결하는데 드는 비용이 주어진다. 이 비용의 정보는 세 개의 정수로 주어지는데, 만약에 a b c 가 주어져 있다고 하면 a컴퓨터와 b컴퓨터를 연결하는데 비용이 c (1 ≤ c ≤ 10,000) 만큼 든다는 것을 의미한다. a와 b는 같을 수도 있다.

## 출력

* 모든 컴퓨터를 연결하는데 필요한 최소비용을 첫째 줄에 출력한다.

## 입력 예제 1

```
6
9
1 2 5
1 3 4
2 3 2
2 4 7
3 4 6
3 5 11
4 5 3
4 6 8
5 6 8
```

## 출력 예제 1

```
23
```

## 풀이

* 주어진 컴퓨터들을 모두 연결하면서 전체 연결 비용의 합을 최소로 하는 간선들의 비용 합을 구하는 문제. 입력은 컴퓨터 수, 가능한 연결선 수, 그리고 각각의 연결 비용이 주어짐.

* 최소 스패닝 트리이므로 크루스칼/프림 둘중 하나를 선택해야 하는 문제이기도 하다.

* 문제의 조건을 살펴보면 모든 컴퓨터를 연결하고, 최소 비용을 구하며, 입력이 간선 형태로 주어져 있으므로, 정점 하나를 중심으로 하는 프림 알고리즘 보다는 간선을 중심으로 하는 크루스칼 알고리즘으로 푸는 방식이 더 적절하다.

* 크루스칼 알고리즘 작동은 간단하게 묘사하면 아래와 같다.

```
1. 모든 연결선을 비용 기준으로 정렬하고

2. 싼 것부터 하나씩 보면서

3. 이미 연결된 컴퓨터끼리는 건너뛰고

4. 결국 n-1개의 간선만 선택
```

## 소스코드

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer
import java.util.PriorityQueue

data class Edge(val u: Int, val v: Int, val w: Int) : Comparable<Edge> {
    override fun compareTo(other: Edge): Int = this.w - other.w
}

fun find(parent: IntArray, x: Int): Int {
    if (parent[x] != x) parent[x] = find(parent, parent[x])
    return parent[x]
}

fun union(parent: IntArray, a: Int, b: Int) {
    val ra = find(parent, a)
    val rb = find(parent, b)
    if (ra != rb) parent[rb] = ra
}

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))
    var st = StringTokenizer(br.readLine())
    val n = st.nextToken().toInt()

    st = StringTokenizer(br.readLine())
    val m = st.nextToken().toInt()

    val pq = PriorityQueue<Edge>()
    repeat(m) {
        st = StringTokenizer(br.readLine())
        val a = st.nextToken().toInt()
        val b = st.nextToken().toInt()
        val w = st.nextToken().toInt()
        pq.add(Edge(a, b, w))
    }

    val parent = IntArray(n + 1) { it }
    var result = 0
    var count = 0

    while (pq.isNotEmpty() && count < n - 1) {
        val e = pq.poll()
        val ru = find(parent, e.u)
        val rv = find(parent, e.v)
        if (ru != rv) {
            union(parent, ru, rv)
            result += e.w
            count++
        }
    }

    println(result)
}
```
