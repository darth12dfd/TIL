# 전력난

## 출처

* https://www.acmicpc.net/problem/6497

## 문제

* 성진이는 한 도시의 시장인데 거지라서 전력난에 끙끙댄다. 그래서 모든 길마다 원래 켜져 있던 가로등 중 일부를 소등하기로 하였다. 길의 가로등을 켜 두면 하루에 길의 미터 수만큼 돈이 들어가는데, 일부를 소등하여 그만큼의 돈을 절약할 수 있다.

* 그러나 만약 어떤 두 집을 왕래할 때, 불이 켜져 있지 않은 길을 반드시 지나야 한다면 위험하다. 그래서 도시에 있는 모든 두 집 쌍에 대해, 불이 켜진 길만으로 서로를 왕래할 수 있어야 한다.

* 위 조건을 지키면서 절약할 수 있는 최대 액수를 구하시오.

## 입력

* 입력은 여러 개의 테스트 케이스로 구분되어 있다.

* 각 테스트 케이스의 첫째 줄에는 집의 수 m과 길의 수 n이 주어진다. (1 ≤ m ≤ 200000, m-1 ≤ n ≤ 200000)

* 이어서 n개의 줄에 각 길에 대한 정보 x, y, z가 주어지는데, 이는 x번 집과 y번 집 사이에 양방향 도로가 있으며 그 거리가 z미터라는 뜻이다. (0 ≤ x, y < m, x ≠ y)

* 도시는 항상 연결 그래프의 형태이고(즉, 어떤 두 집을 골라도 서로 왕래할 수 있는 경로가 있다), 도시상의 모든 길의 거리 합은 231미터보다 작다.

* 입력의 끝에서는 첫 줄에 0이 2개 주어진다.

## 출력

* 각 테스트 케이스마다 한 줄에 걸쳐 절약할 수 있는 최대 비용을 출력한다.

## 입력 예제 1

```
7 11
0 1 7
0 3 5
1 2 8
1 3 9
1 4 7
2 4 5
3 4 15
3 5 6
4 5 8
4 6 9
5 6 11
0 0
```

## 출력 예제 1

```
51
```

## 풀이

* 문제에서 “모든 정점을 연결하면서 비용 최소” 이 조건이 나오면 거의 자동으로 떠올려야 하는 게 최소 신장 트리(MST)이다. MST의 성질은 아래와 같다.

* MST의 성질: 
            - 정점 m개 → 간선은 m-1개
            - 모든 정점이 연결됨
            - 간선 가중치 합이 최소

* 가로등을 꼭 켜야 하는 도로만 남긴 구조 = MST

* 문제는 MST 비용 자체가 아니라, 절약 가능한 비용을 묻고 있음.

* 그래서 계산은 이렇게 나뉜다:
                                - 모든 도로를 다 켰을 때의 비용
                                - 입력으로 주어지는 모든 간선 가중치의 합
                                - MST를 구성했을 때 필요한 최소 비용
                                - 절약 비용 = 전체 비용 − MST 비용
  
* MST를 만드는 대표적인 방법 두 가지:
                                      - 프림 (PriorityQueue + 인접 리스트)
                                      - 크루스칼 (간선 정렬 + 유니온 파인드) ← 이 문제에 딱

* 이 문제는:
            - 간선이 리스트 형태로 주어짐
            - 여러 테스트 케이스
            - 구현 단순함

=> 크루스칼로 하는 것이 깔끔

### 크루스칼 알고리즘 흐름

1. 모든 간선을 가중치 기준 오름차순 정렬

  - 가장 싼 도로부터 고려

2.  Union-Find 준비

  - 각 집(정점)을 자기 자신을 부모로 초기화

3.  간선을 하나씩 보면서

  - 두 정점이 아직 연결 안 되어 있으면  연결한다 (union)

  -  MST 비용에 이 간선 비용을 더한다

  - 이미 연결되어 있으면 사이클이 되므로 버린다

4. 간선 m-1개가 선택되면 종료

## 소스코드

```kotlin
package graph.mst

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer
import java.util.PriorityQueue

data class Edge(val u: Int, val v: Int, val w: Int) : Comparable<Edge> {
    override fun compareTo(other: Edge) = this.w - other.w
}

class UnionFind(val n: Int) {
    private val parent = IntArray(n) { it }
    private val rank = IntArray(n) { 0 }

    fun find(x: Int): Int {
        if (parent[x] != x) {
            parent[x] = find(parent[x])
        }
        return parent[x]
    }

    fun union(a: Int, b: Int): Boolean {
        val ra = find(a)
        val rb = find(b)
        if (ra == rb) return false

        if (rank[ra] < rank[rb]) parent[ra] = rb
        else if (rank[ra] > rank[rb]) parent[rb] = ra
        else {
            parent[rb] = ra
            rank[ra]++
        }
        return true
    }
}

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))
    val sb = StringBuilder()

    while (true) {
        val line = br.readLine() ?: break
        val st = StringTokenizer(line)
        val m = st.nextToken().toInt()
        val n = st.nextToken().toInt()

        if (m == 0 && n == 0) break

        val pq = PriorityQueue<Edge>()
        var totalWeight = 0L

        repeat(n) {
            val tokens = StringTokenizer(br.readLine())
            val x = tokens.nextToken().toInt()
            val y = tokens.nextToken().toInt()
            val z = tokens.nextToken().toInt()
            pq.add(Edge(x, y, z))
            totalWeight += z
        }

        val uf = UnionFind(m)
        var mstWeight = 0L
        var edgesUsed = 0

        while (pq.isNotEmpty() && edgesUsed < m - 1) {
            val (u, v, w) = pq.poll()
            if (uf.union(u, v)) {
                mstWeight += w
                edgesUsed++
            }
        }

        val saved = totalWeight - mstWeight
        sb.append(saved).append('\n')
    }

    print(sb.toString())
}

```
