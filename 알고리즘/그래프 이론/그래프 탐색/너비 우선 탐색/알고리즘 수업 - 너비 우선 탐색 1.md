# 알고리즘 수업 - 너비 우선 탐색 1 

## 출처 

* [https://www.acmicpc.net/problem/16953](https://www.acmicpc.net/problem/24444)

## 문제

* 오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.

* N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

* 너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.

```
bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점
    for each v ∈ V - {R}
        visited[v] <- NO;
    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.
    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.
    while (Q ≠ ∅) {
        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.
        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)
            if (visited[v] = NO) then {
                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.
                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.
            }
    }
}
```

## 입력

* 첫째 줄에 정점의 수 N (5 ≤ N ≤ 100,000), 간선의 수 M (1 ≤ M ≤ 200,000), 시작 정점 R (1 ≤ R ≤ N)이 주어진다.

* 다음 M개 줄에 간선 정보 u v가 주어지며 정점 u와 정점 v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤ u < v ≤ N, u ≠ v) 모든 간선의 (u, v) 쌍의 값은 서로 다르다.

## 출력

* 첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.

## 입력 예제 1

```
5 5 1
1 4
1 2
2 3
2 4
3 4
```

## 출력 예제 1

```
1
2
4
3
0
```

* 정점 1번에서 정점 2번, 정점 4번을 순서대로 방문한다. 정점 2번에서 정점 3번을 방문한다. 정점 5번은 정점 1번에서 방문할 수 없다.

## 풀이

* 입력으로부터 그래프를 구성하고 인접리스트를 만든 다음 BFS를 수행하는 비교적 단순한 문제이다.

* 여기서 다른 점은 bfs 알고리즘을 수행하면서 order 배열을 사용해서 각 노드의 방문순서를 저장한다. 이때 방문하지 않은 노드는 0으로 초기화해두면 된다.

## 소스코드

```kotlin
package graphtheory.graphtraversal.bfs

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))

    val st = StringTokenizer(br.readLine())
    val n = st.nextToken().toInt()
    val m = st.nextToken().toInt()
    val r = st.nextToken().toInt()

    // 인접 리스트
    val adj = Array(n + 1) { mutableListOf<Int>() }

    repeat(m) {
        val st2 = StringTokenizer(br.readLine())
        val u = st2.nextToken().toInt()
        val v = st2.nextToken().toInt()
        adj[u].add(v)
        adj[v].add(u)
    }

    // 정점별 인접 정점 오름차순 정렬
    for (i in 1..n) {
        adj[i].sort()
    }

    val visited = BooleanArray(n + 1)
    val order = IntArray(n + 1)

    // 큐를 IntArray로 직접 구현 (성능 위해)
    val queue = IntArray(n + 5)
    var head = 0
    var tail = 0

    var cnt = 1

    // 시작 정점
    visited[r] = true
    order[r] = cnt
    queue[tail++] = r

    // BFS
    while (head < tail) {
        val cur = queue[head++]

        for (next in adj[cur]) {
            if (!visited[next]) {
                visited[next] = true
                order[next] = ++cnt
                queue[tail++] = next
            }
        }
    }

    val sb = StringBuilder()
    for (i in 1..n) {
        sb.append(order[i]).append('\n')
    }
    print(sb.toString())
}

```
