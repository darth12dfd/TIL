# 알고리즘 수업 - 너비 우선 탐색 2

## 출처

* https://www.acmicpc.net/problem/24445

## 문제

* 오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.

* N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

* 너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.

```
bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점
    for each v ∈ V - {R}
        visited[v] <- NO;
    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.
    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.
    while (Q ≠ ∅) {
        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.
        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합.(정점 번호를 내림차순으로 방문한다)
            if (visited[v] = NO) then {
                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.
                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.
            }
    }
}
```

## 입력

* 첫째 줄에 정점의 수 N (5 ≤ N ≤ 100,000), 간선의 수 M (1 ≤ M ≤ 200,000), 시작 정점 R (1 ≤ R ≤ N)이 주어진다.

* 다음 M개 줄에 간선 정보 u v가 주어지며 정점 u와 정점 v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤ u < v ≤ N, u ≠ v) 모든 간선의 (u, v) 쌍의 값은 서로 다르다.

## 출력

* 첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.

## 입력 예제 1

```
5 5 1
1 4
1 2
2 3
2 4
3 4
```

## 출력 예제 1

```
1
3
4
2
0
```

## 풀이

* 기본적인 bfs 문제에 간선의 수치가 1로 통일되고, 인접 정점들 중에서 내림차순으로 우선방문하여 순서가 이뤄지는 구조이다.

* adj: Array<MutableList<Int>> 로 인접 리스트 구성.

* 모든 정점의 인접 리스트를 sortDescending() 해서 내림차순 정렬.

* visited: IntArray 에 “방문 순서” 저장 (0이면 아직 미방문).

* BFS: ArrayDeque<Int>를 큐로 사용. 시작 정점 R을 큐에 넣고 visited[R] = 1부터 시작, 큐에서 하나씩 꺼내면서 인접 정점들을 순회. 아직 방문 안 한 정점(visited[next] == 0)은 방문 순서를 증가시키며 큐에 추가. 마지막에 1..N까지 visited[i] 출력.

## 소스코드

```kotlin
package graph.bfs

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer
import java.util.ArrayDeque

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))
    val st = StringTokenizer(br.readLine())

    val n = st.nextToken().toInt()
    val m = st.nextToken().toInt()
    val r = st.nextToken().toInt()

    // 인접 리스트 초기화
    val adj = Array(n + 1) { mutableListOf<Int>() }

    // 간선 입력 (무방향 그래프)
    repeat(m) {
        val line = StringTokenizer(br.readLine())
        val u = line.nextToken().toInt()
        val v = line.nextToken().toInt()
        adj[u].add(v)
        adj[v].add(u)
    }

    // 인접 리스트를 내림차순으로 정렬
    for (i in 1..n) {
        adj[i].sortDescending()
    }

    // 방문 순서 기록용 배열 (0이면 미방문)
    val visited = IntArray(n + 1)
    var order = 1

    // BFS
    val q: ArrayDeque<Int> = ArrayDeque()
    q.addLast(r)
    visited[r] = order++

    while (q.isNotEmpty()) {
        val cur = q.removeFirst()

        for (next in adj[cur]) {
            if (visited[next] == 0) {
                visited[next] = order++
                q.addLast(next)
            }
        }
    }

    // 출력
    val sb = StringBuilder()
    for (i in 1..n) {
        sb.append(visited[i]).append('\n')
    }
    print(sb.toString())
}
```
