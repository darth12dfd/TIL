# 양팔 저울

## 출처

* https://www.acmicpc.net/problem/2629

## 문제

* 양팔 저울과 몇 개의 추가 주어졌을 때, 이를 이용하여 입력으로 주어진 구슬의 무게를 확인할 수 있는지를 결정하려고 한다.

* 무게가 각각 1g과 4g인 두 개의 추가 있을 경우, 주어진 구슬과 1g 추 하나를 양팔 저울의 양쪽에 각각 올려놓아 수평을 이루면 구슬의 무게는 1g이다. 또 다른 구슬이 4g인지를 확인하려면 1g 추 대신 4g 추를 올려놓으면 된다.

* 추들의 무게와 확인할 구슬들의 무게가 입력되었을 때, 주어진 추만을 사용하여 구슬의 무게를 확인 할 수 있는지를 결정하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에는 추의 개수가 자연수로 주어진다. 추의 개수는 30 이하이다. 둘째 줄에는 추의 무게들이 자연수로 가벼운 것부터 차례로 주어진다. 같은 무게의 추가 여러 개 있을 수도 있다. 추의 무게는 500g이하이며, 입력되는 무게들 사이에는 빈칸이 하나씩 있 다. 세 번째 줄에는 무게를 확인하고자 하는 구슬들의 개수가 주어진다. 확인할 구슬의 개수는 7이하이다. 네 번째 줄에는 확인하고자 하는 구슬들의 무게가 자연수로 주어지며, 입력되는 무게들 사이에는 빈 칸이 하나씩 있다. 확인하고자 하는 구슬의 무게는 40,000보다 작거나 같은 자연수이다.

## 출력

* 주어진 각 구슬의 무게에 대하여 확인이 가능하면 Y, 아니면 N 을 차례로 출력한다. 출력은 한 개의 줄로 이루어지며, 각 구슬에 대한 답 사이에는 빈칸을 하나씩 둔다.

## 입력 예제 1

```
2
1 4
2
3 2
```

## 출력 예제 1

```
Y N
```

## 풀이

* 무게를 측정할 구슬을 왼쪽에 항상 놓는 경우, 추를 저울에 놓는 경우는 다음 3가지 경우가 있다.

```
1. 다음 추를 저울의 구슬의 반대쪽에 놓는 경우
2. 다음 추를 저울에 올리지 않는 경우
3. 다음 추를 저울의 구슬과 함께 놓는 경우
```

* 구슬의 개수를 깊이라 하고, 측정해아하는 구슬을 목적지라고 하면, 목적지를 갈 수 있는지 판단하라는 문제이다. 즉, 이 문제는 깊이 우선 탐색으로 풀이한다.

* 먼저, 크기가 (추의 개수+1) * (15001: 추들의 무게의 합의 최대값보다 1 큰 값)인 Boolean 타입의 이차원 배열을 만든다. 이 이차원 배열의 의미는 추의 개수가 i개 일 때, 무게 j를 측정하는 것이 가능한지를 저정하는 배열이다.

* 그럼 아까 위에서 묘사한 세 가지 경우의 수는 아래와 같은 식으로 바뀐다.

```
1. w+weights[cnt](여기서 cnt는 추의 개수를 의미한다.)
2. w
3. |w-weights[cnt]|
```

* 그리고 dfs 함수를 만든다. 파라미터는 깊이(추의 개수)와 측정하는 무게로 받는다. 두 패러미터를 인자로 위에서 만든 이차원 배열의 인자로 설정한 뒤 해당 값이 가능하면 함수를 리턴하고 그렇지 않으면 해당 인덱스에 있는 값을 true로 저장한다.

* 그리고, 만약 추의 개수가 최대 깊이와 동일할 경우 역시 함수를 리턴한다.

* 그 다음, 위의 3가지 경우에 대하여 함수를 재귀호출한다. 코드는 아래와 같다.

```
dfs(cnt+1,w+weights[cnt])//한 쪽에 추가로 놓은 경우
dfs(cnt+1,w)//아무 쪽에도 놓지 않은 경우
dfs(cnt+1,Math.abs(w-weights[cnt]))//구슬이 있는 쪽에 놓은 경우
```

* 함수를 실행할 때, dfs(0,0)부터 실행한다. 이 코드의 의미를 문자 그대로 해석하면 0개의 추로 무게 0을 만드는 것이 가능한지를 검사하는 함수이다. 이는 가능하므로 먼저 실행한다.

## 소스코드

```kotlin
package graphtheory.graphtraversal.dfs

import java.io.*
import java.util.*

fun main()=with(BufferedReader(InputStreamReader(System.`in`))){
    val bw=BufferedWriter(OutputStreamWriter(System.`out`))

    val weight=readLine().toInt()//추의 개수(30 이하의 자연수)

    var weights=IntArray(weight,{0})//추들의 무게를 저장할 배열(500 이하의 자연수)

    var isPossible=Array(weight+1,{BooleanArray(15001,{false})})//추의 개수가 i개 일 때, j라는 숫자를 만들 수 있는 가능성을 저장할 이차원 배열

    //저울에 추를 놓는 행위를 시행하는 함수
    fun dfs(cnt:Int,w:Int){
        //만약 cnt라는 숫자로 무게 w를 만드는 것이 가능하면 함수를 리턴한다.
        if(isPossible[cnt][w]){
            return
        }
        isPossible[cnt][w]=true//그렇지 않은 경우 해당 값을 true로 저장한다.

        if(cnt==weight){//만약 함수에 입력된 추의 개수가 문제에서 입력한 추의 개수와 동일할 경우 함수를 리턴한다.
            return
        }

        //한 쪽에 추가로 놓은 경우
        dfs(cnt+1,w+weights[cnt])
        //아무 쪽에도 놓지 않은 경우
        dfs(cnt+1,w)
        //구슬이 있는 쪽에 놓은 경우
        dfs(cnt+1,Math.abs(w-weights[cnt]))
    }

    var st=StringTokenizer(readLine())

    for(i in 0 until weight){
        weights[i]=st.nextToken().toInt()
    }

    dfs(0,0)//0개의 추로 무게 0을 만드는 경우는 언제나 가능하므로 해당 값을 기점으로 함수를 실행한다.

    val m=readLine().toInt()//무게를 확인하고자 하는 구슬의 개수(7이 하의 자연수)

    st= StringTokenizer(readLine())

    for(i in 0 until m){
        val marble=st.nextToken().toInt()//해당 구슬의 무게

        //무게가 15000이 넘어가는 구슬은 무게를 확인할 수 없음(추 무게의 최대 총합이 30(추의 최대 개수)*500(한 추의 최대 무게)=15000이므로)
        if(marble > 15000){
            bw.write("N ")
        }
        else{//무게가 15000이 넘어가지 않는 경우
            if(isPossible[weight][marble]){//입력받은 추의 개수로 해당 구슬의 무게를 만드는 것이 가능한 경우
                bw.write("Y ")
            }
            else{//입력받은 추의 개수로 해당 구슬의 무게를 표현하는 것이 불가능한 경우
                bw.write("N ")
            }
        }
    }


    bw.flush()
    bw.close()
    close()
}
```
