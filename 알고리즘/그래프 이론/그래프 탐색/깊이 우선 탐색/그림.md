# 그림

## 출처

* https://www.acmicpc.net/problem/1926

## 입력

* 어떤 큰 도화지에 그림이 그려져 있을 때, 그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력하여라. 단, 그림이라는 것은 1로 연결된 것을 한 그림이라고 정의하자. 가로나 세로로 연결된 것은 연결이 된 것이고 대각선으로 연결이 된 것은 떨어진 그림이다. 그림의 넓이란 그림에 포함된 1의 개수이다.

## 출력

* 첫째 줄에 도화지의 세로 크기 n(1 ≤ n ≤ 500)과 가로 크기 m(1 ≤ m ≤ 500)이 차례로 주어진다. 두 번째 줄부터 n+1 줄 까지 그림의 정보가 주어진다. (단 그림의 정보는 0과 1이 공백을 두고 주어지며, 0은 색칠이 안된 부분, 1은 색칠이 된 부분을 의미한다)

## 예제 출력 1

```
6 5
1 1 0 1 1
0 1 1 0 0
0 0 0 0 0
1 0 1 1 1
0 0 1 1 1
0 0 1 1 1
```

## 출력 예제 1

```
4
9
```

## 풀이

* dfs, bfs로 푸는 방법이 있고, 그중 n,m값이 500 이하까지 받기 때문에 재귀 깊이가 깊어질 수 있어 bfs로 하는 것이 안전하지만 이번엔 dfs로 한번 해보았다. 그 풀이는 아래와 같다.

```
1.격자를 전부 순회
2. 1이고 아직 방문 안 했으면 → 새로운 그림 시작
3. DFS로 상하좌우 연결된 모든 1을 방문
4. DFS가 반환한 값 = 해당 그림의 넓이
5.그림 개수 +1, 최대 넓이 갱신
```

## 소스코드

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer

private lateinit var board: Array<IntArray>
private lateinit var visited: Array<BooleanArray>
private var n = 0
private var m = 0

private val dr = intArrayOf(-1, 1, 0, 0)
private val dc = intArrayOf(0, 0, -1, 1)

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))
    val st = StringTokenizer(br.readLine())

    n = st.nextToken().toInt()
    m = st.nextToken().toInt()

    board = Array(n) { IntArray(m) }
    visited = Array(n) { BooleanArray(m) }

    for (i in 0 until n) {
        val line = StringTokenizer(br.readLine())
        for (j in 0 until m) {
            board[i][j] = line.nextToken().toInt()
        }
    }

    var pictureCount = 0
    var maxArea = 0

    for (i in 0 until n) {
        for (j in 0 until m) {
            if (board[i][j] == 1 && !visited[i][j]) {
                pictureCount++
                val area = dfs(i, j)
                if (area > maxArea) maxArea = area
            }
        }
    }

    println(pictureCount)
    println(maxArea)
}

fun dfs(r: Int, c: Int): Int {
    visited[r][c] = true
    var area = 1

    for (k in 0..3) {
        val nr = r + dr[k]
        val nc = c + dc[k]

        if (nr !in 0 until n || nc !in 0 until m) continue
        if (visited[nr][nc]) continue
        if (board[nr][nc] == 0) continue

        area += dfs(nr, nc)
    }

    return area
}

```
