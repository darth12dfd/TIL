# 알고리즘 수업 - 깊이 우선 탐색 2

## 출처

* https://www.acmicpc.net/problem/24480

## 문제

* 오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.

* N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

* 깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.

```
dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점
    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.
    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 내림차순으로 방문한다)
        if (visited[x] = NO) then dfs(V, E, x);
}
```

## 입력

* 첫째 줄에 정점의 수 N (5 ≤ N ≤ 100,000), 간선의 수 M (1 ≤ M ≤ 200,000), 시작 정점 R (1 ≤ R ≤ N)이 주어진다.

* 다음 M개 줄에 간선 정보 u v가 주어지며 정점 u와 정점 v의 가중치 1인 양방향 간선을 나타낸다. (1 ≤ u < v ≤ N, u ≠ v) 모든 간선의 (u, v) 쌍의 값은 서로 다르다.

## 출력

* 첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.

## 입력 예제 1

```
5 5 1
1 4
1 2
2 3
2 4
3 4
```

## 출력 예제 1

```
1
4
3
2
0
```

## 풀이

* 기본적인 DFS 문제에서 인접정점들을 내림차순으로 방문하며 그 순서를 기록하는 것이 적용되어있는 문제

* 우선 그래프 표현

```
adj[v] : 정점 v에 인접한 정점들의 리스트
Array(n + 1) { mutableListOf<Int>() }
```

* 인접 리스트 정렬 방향

  - DFS는 “인접 정점들을 내림차순으로 방문”해야 함.

  - 스택은 LIFO라서: 오름차순으로 push하면, ➜ pop 순서는 내림차순이 됨. 따라서: ```adj[i].sort() // 오름차순 정렬```한 뒤, 그대로 앞에서부터 push만 해주면 됨.

* 반복 DFS (스택 사용)

  - 방문 순서를 기록할 배열:
    ```
    val order = IntArray(n + 1) // 0이면 아직 방문 X
    var cnt = 0
    ```

  - DFS 흐름:
    ```
    val stack = ArrayDeque<Int>()
    stack.addLast(r)
    
    while (stack.isNotEmpty()) {
        val v = stack.removeLast()
        if (order[v] != 0) continue  // 이미 방문한 정점이면 건너뛰기
    
        order[v] = ++cnt
    
        // 인접 정점들을 오름차순으로 정렬해두었으므로
        // 그대로 push하면 pop 시 내림차순으로 방문됨
        for (next in adj[v]) {
            if (order[next] == 0) {
                stack.addLast(next)
            }
        }
    }
    ```
## 소스코드

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer
import java.util.ArrayDeque

fun main() = with(BufferedReader(InputStreamReader(System.`in`))) {
    val st = StringTokenizer(readLine())
    val n = st.nextToken().toInt()   // 정점 수
    val m = st.nextToken().toInt()   // 간선 수
    val r = st.nextToken().toInt()   // 시작 정점

    // 인접 리스트 초기화
    val adj = Array(n + 1) { mutableListOf<Int>() }

    // 간선 입력 (무방향 그래프)
    repeat(m) {
        val token = StringTokenizer(readLine())
        val u = token.nextToken().toInt()
        val v = token.nextToken().toInt()
        adj[u].add(v)
        adj[v].add(u)
    }

    // 인접 정점 오름차순 정렬
    // (스택에 오름차순으로 push → pop 시 내림차순 방문)
    for (i in 1..n) {
        adj[i].sort()
    }

    val order = IntArray(n + 1)  // 방문 순서 저장, 0이면 아직 방문 X
    var cnt = 0

    val stack = ArrayDeque<Int>()
    stack.addLast(r)

    while (stack.isNotEmpty()) {
        val v = stack.removeLast()

        if (order[v] != 0) continue  // 이미 방문했으면 스킵

        order[v] = ++cnt             // v를 방문 순서 cnt로 기록

        // adj[v]는 오름차순 정렬 상태
        // 그대로 push하면 pop 시 큰 번호부터 나오므로
        // 내림차순 방문이 자연스럽게 성립
        for (next in adj[v]) {
            if (order[next] == 0) {
                stack.addLast(next)
            }
        }
    }

    val sb = StringBuilder()
    for (i in 1..n) {
        sb.append(order[i]).append('\n')
    }
    print(sb.toString())
}

```
