# 극장 좌석

## 출처

* https://www.acmicpc.net/problem/2302

## 문제

* 어떤 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다. 공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다. 예를 들어서, 입장권에 5번이 쓰여 있으면 5번 좌석에 앉아야 한다. 단, 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다. 예를 들어서, 7번 입장권을 가진 사람은 7번 좌석은 물론이고, 6번 좌석이나 8번 좌석에도 앉을 수 있다. 그러나 5번 좌석이나 9번 좌석에는 앉을 수 없다.

* 그런데 이 극장에는 “VIP 회원”들이 있다. 이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다.

* 오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다. VIP 회원들의 좌석 번호들이 주어졌을 때, 사람들이 좌석에 앉는 서로 다른 방법의 가짓수를 구하는 프로그램을 작성하시오.

* 예를 들어서, 그림과 같이 좌석이 9개이고, 4번 좌석과 7번 좌석이 VIP석인 경우에 <123456789>는 물론 가능한 배치이다. 또한 <213465789> 와 <132465798> 도 가능한 배치이다. 그러나 <312456789> 와 <123546789> 는 허용되지 않는 배치 방법이다.

<img width="408" height="308" alt="image" src="https://github.com/user-attachments/assets/295cc250-4b64-4e63-bc86-70d4fa8ea2a7" />


## 입력

* 첫째 줄에는 좌석의 개수 N이 입력된다. N은 1 이상 40 이하이다. 둘째 줄에는 고정석의 개수 M이 입력된다. M은 0 이상 N 이하이다. 다음 M 개의 줄에는 고정석의 번호가 작은 수부터 큰 수의 순서로 한 줄에 하나씩 입력된다.

## 출력

* 주어진 조건을 만족하면서 사람들이 좌석에 앉을 수 있는 방법의 가짓수를 출력한다. 방법의 가짓수는 2,000,000,000을 넘지 않는다. (2,000,000,000 < 2^31-1)

## 입력 예제 1

```
9
2
4
7
```

## 출력 예제 1

```
12
```

## 풀이

* VIP 좌석 때문에 연속된 일반 좌석 구간으로 나누고, 각 구간의 배치 가능 수를 피보나치 수열을 이용해 구한 뒤 모두 곱하는 방식으로 해결

* 전체 좌석 수 N이 있고 VIP 좌석이 M개 주어진다.

* VIP 자리는 고정이므로 움직일 수 없고, 그 사이 나머지 구간만 자리를 바꿀 수 있다.

* 연속된 일반 좌석 길이에 대해 가능한 모든 자리 교환 경우의 수는 피보나치 수로 표현된다.

```
길이 0 → 1

길이 1 → 1

길이 2 → 2

길이 i → dp[i] = dp[i − 1] + dp[i − 2]
```

## 소스코드

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader

fun main() {
    val reader = BufferedReader(InputStreamReader(System.`in`))

    // 전체 좌석 수 N
    val N = reader.readLine().trim().toInt()

    // VIP 좌석 수 M
    val M = reader.readLine().trim().toInt()

    // VIP 좌석 위치 입력
    val vip = IntArray(M)
    for (i in 0 until M) {
        vip[i] = reader.readLine().trim().toInt()
    }

    // DP 배열 (0..N) 범위로 피보나치 수 계산
    val dp = LongArray(N + 1)
    dp[0] = 1L
    dp[1] = 1L
    if (N >= 2) dp[2] = 2L

    for (i in 3..N) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }

    var answer = 1L
    var prev = 0

    // VIP 좌석 사이의 연속 구간 길이에 따른 경우의 수 계산
    for (vipSeat in vip) {
        val length = vipSeat - prev - 1
        if (length >= 0) {
            answer *= dp[length]
        }
        prev = vipSeat
    }

    // 마지막 VIP 뒤의 구간 처리
    val tail = N - prev
    if (tail >= 0) answer *= dp[tail]

    println(answer)
}

```
