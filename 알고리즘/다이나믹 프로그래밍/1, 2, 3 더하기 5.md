# 1, 2, 3 더하기 5

## 출처

* https://www.acmicpc.net/problem/15990

## 문제

* 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.

```
1+2+1
1+3
3+1
```

* 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.

## 출력

* 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 1,000,000,009로 나눈 나머지를 출력한다.

## 입력 예제 1

```
3
4
7
10
```

## 출력 예제 1

```
3
9
27
```

## 풀이

* dp 배열을 2차원 배열로 설정한다. 이 때 dp배열에서 행의 값을 분할해야하는 자연수 열의 값은 행의 값을 수식으로 표현할 때 맨 끝의 피연산자가 1,2,3인 경우로 설정한다. 행의 크기는 10만, 열의 크기는 3으로 설정한다.

* 그럼 4 를 분할할 때, 1이 수식 끝에 오는 경우 2가 수식 끝에 오는 경우 3이 수식 끝에 오는 경우가 있다.

* 먼저 1이 수식 끝에 오는 경우에는, 그 앞에서 수식으로 3을 만드는 경우를 조사한다. 3을 만드는 경우는 dp[3][1], dp[3][2], dp[3][3] 이 있는데 이때, dp[3][1]은 같은 숫자가 연속 되므로 해당이 되지 않는다. 따라서 수식은 아래와 같다.

```
dp[4][1] = dp[3][2] + dp[3][3]
```

* 그 다음 2가 수식 끝에 오는 경우, 그 앞에 2가 되므로 애초에 해당이 안된다. 따라서 이 경우 5로 가정하고 온다. 5를 분할할 때, 2가 수식 끝에 오는 경우는 그 앞에서 수식 3을 만드는 경우이다. 이는 dp[3][1], dp[3][2],dp[3][3]이다. 이때 dp[3][2]는 2가 연속되므로 해당되지 않는다. 이를 표현하면 아래와 같다.

```
dp[5][2] = dp[3][1] + dp[3][3]
```

* 그 다음 6를 분할할 때 3이 수식 끝에 오는 경우는 그 앞에 3가 존재하는 경우를 조사한다. 이는 dp[3][1] dp[3][2] dp[3][3] 이 해당되는데 dp[3][3]은 숫자가 연속되므로 해당되지 않는다. 이를 표현하면 아래와 같다.

```
dp[6][3] = dp[3][1] + dp[3][2]
```

* 이 세 가지 수식을 점화식으로 표현하면 아래와 같다.

```
dp[i][1] = dp[i-1][2] + dp[i-1][3]
dp[i][2] = dp[i-2][1] + dp[i-2][3]
dp[i][3] = dp[i-3][1] + dp[i-3][2]
```

## 소스코드

```kotlin
package dynamicprograming

import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.InputStreamReader
import java.io.OutputStreamWriter

fun main() = with(BufferedReader(InputStreamReader(System.`in`))){

    val bw = BufferedWriter(OutputStreamWriter(System.`out`))

    val T = readLine().toInt()//테스트 케이스의 개수

    var dp = Array(100001, { LongArray( 4, { 0 } ) } )//이차원 dp 배열

    dp[1][1] = 1// 1 = 1
    dp[2][2] = 1// 2 = 2
    dp[3][3] = 1// 3 = 3

    dp[3][1] = 1// 3 = 2 + 1
    dp[3][2] = 1// 3 = 1 + 2

    //4 이후 부터 점화식 적용
   for(i in 4..100000){
       dp[i][1] = (dp[i-1][2] + dp[i-1][3]) % 1000000009
       dp[i][2] = (dp[i-2][1] + dp[i-2][3]) % 1000000009
       dp[i][3] = (dp[i-3][1] + dp[i-3][2]) % 1000000009
    }
    for(i in 0 until T){
        val n = readLine().toInt()

        bw.write("${(dp[n][1] + dp[n][2] + dp[n][3]) % 1000000009}\n")
    }

    bw.flush()
    bw.close()
    close()
}
```
