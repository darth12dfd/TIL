# 제곱수의 합

## 출처

* https://www.acmicpc.net/problem/1699

## 문제

* 어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=3^2+1^2+1^2(3개 항)이다. 이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=2^2+2^2+1^2+1^2+1^2(5개 항)도 가능하다. 이 경우, 수학자 숌크라테스는 “11은 3개 항의 제곱수 합으로 표현할 수 있다.”라고 말한다. 또한 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.

* 주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 100,000)

## 출력

* 주어진 자연수를 제곱수의 합으로 나타낼 때에 그 제곱수 항의 최소 개수를 출력한다.

## 입력 예제 1

```
7
```

## 출력 예제 1

```
4
```

## 풀이

* 처음에는 순수하게 dp로 풀었다. 이때 1,4,9,16같은 제곱수들은 미리 dp배열을 1로 초기화 시키고, 그 다음 1부터 N까지의 수에 대하여 아래와 같은 점화식을 작성하였다.

```
for(i in 1..N){
        for(j in 1 until i){
            dp[i] = Math.min( dp[i], dp[j] + dp[i-j] )//기존의 dp값과 i보다 작은 j의 dp값과 i-j의 dp값을 더한 값 들 중 최댓값을 저장한다.
        }
    }
```

* 다만 위와 같은 방식으로 진행할 경우, N의 숫자가 커질수록 시간이 오래걸린다는 단점이 있다. 실제로 10만을 입력했을 때 값이 출력되는 속도가 현저하게 떨어졌다.

* 그래서 좀 더 시간을 절약하기 위해 점화식을 더 자세히 작성하기로 했다.

* 1부터 N까지의 수들 중 1,4,9,16같이 특정 수들의 제곱수들의 경우는 그 항의 개수가 항상 1이다. 즉 이런 제곱수들을 항상 포함하는 방식으로 점화식을 짜면 된다. 이는 아래와 같다.

```
dp[i] = dp[i-j*j] + 1
```

* 여기서 나오는 1은 항상 들어가는 제곱수를 뜻한다. 이렇게 점화식을 작성하면, N 이하의 모든 자연수들에 대하여 반복문을 돌리지 않아도 되기에 시간이 더 절약된다. 이때 j의 제곱값이 i보다는 항상 작아야 한다.

* 예를들어 N이 13인 경우, 우리가 고려할 건 (13-1)의 최소 제곱수 개수, (13-2^2)의 최소 제곱수의 개수, (13-3^2)의 최소 제곱수 개수 중 최소값을 구하고 거기에 1을 더한 값이 되는 것이다.

* 이렇게 하면, 기존의 13-1 부터 13-12 까지 반복문을 돌릴 필요도 없어 시간이 비약적으로 단축된다.

## 소스코드

```kotlin
package dynamicprograming

import java.io.BufferedReader
import java.io.InputStreamReader

fun main() = with(BufferedReader(InputStreamReader(System.`in`))){
    val N = readLine().toInt()//1이상 10만 이하의 자연수

    var dp = IntArray(N + 1, { 0 } )//1부터 N까지의 자연수들에 대하여 각 자연수의 최소 제곱 항의 개수를 저장할 dp 배열(이때 정수의 최댓값으로 초기화한다.

    //제곱수인 1의 개수로 초기화한다
    for(i in 1..N){
        dp[i] = i
    }

    for(i in 1..N){
        //dp[i] = dp[i-j^2] + (N - 제곱수)의 최소항 개수
        for(j in 1..Math.sqrt(i.toDouble()).toInt()){
            if(dp[i] > dp[i - (j * j)] + 1){//해당 수에서 특정 제곱수(j*j)를 뺀 값에서의 최소 제곱수의 개수에 + 특정 제곱수의 갯수(1)를 더한 값과 기존의 기존의 제곱수의 최소 개수 사이에 비교해서 작은 값을 저장한다.
                dp[i] = dp[i-(j*j)] + 1
            }
        }
    }

    println(dp[N])

    close()
}
```
