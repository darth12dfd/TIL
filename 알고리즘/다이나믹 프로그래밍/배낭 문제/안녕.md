# 안녕

## 출처

* https://www.acmicpc.net/problem/1535

## 문제

* 세준이는 성형수술을 한 후에 병원에 너무 오래 입원해 있었다. 이제 세준이가 병원에 입원한 동안 자기를 생각해준 사람들에게 감사하다고 말할 차례이다.

* 세준이를 생각해준 사람은 총 N명이 있다. 사람의 번호는 1번부터 N번까지 있다. 세준이가 i번 사람에게 인사를 하면 L[i]만큼의 체력을 잃고, J[i]만큼의 기쁨을 얻는다. 세준이는 각각의 사람에게 최대 1번만 말할 수 있다.

* 세준이의 목표는 주어진 체력내에서 최대한의 기쁨을 느끼는 것이다. 세준이의 체력은 100이고, 기쁨은 0이다. 만약 세준이의 체력이 0이나 음수가 되면, 죽어서 아무런 기쁨을 못 느낀 것이 된다. 세준이가 얻을 수 있는 최대 기쁨을 출력하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 사람의 수 N(<=20)이 들어온다. 둘째 줄에는 각각의 사람에게 인사를 할 때, 잃는 체력이 1번 사람부터 순서대로 들어오고, 셋째 줄에는 각각의 사람에게 인사를 할 때, 얻는 기쁨이 1번 사람부터 순서대로 들어온다. 체력과 기쁨은 100보다 작거나 같은 자연수 또는 0이다.

## 출력

* 첫째 줄에 세준이가 얻을 수 있는 최대 기쁨을 출력한다.

## 입력 예제 1

```
3
1 21 79
20 30 25
```

## 출력 예제 1

```
50
```

## 풀이

* 각 사람마다 체력 손실을 무게로, 각 사람이 주는 기쁨을 가치로, 그리고 최대 체력을 최대 무게로 생각하면, 이 문제는 전형적인 배낭 문제라고 볼 수 있다.

* 

## 소스코드

```kotlin
package dynamicprograming.knapsack

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.*

fun main()=with(BufferedReader(InputStreamReader(System.`in`))){
    val N=readLine().toInt()//감사 인사를 전할 사람 수(20 이하의 자연수)

    var st=StringTokenizer(readLine())

    var L=IntArray(N+1,{0})//잃는 체력
    var J=IntArray(N+1,{0})//얻는 기쁨

    for(i in 1..N){
        L[i]=st.nextToken().toInt()
    }

    st= StringTokenizer(readLine())

    for(i in 1..N){
        J[i]=st.nextToken().toInt()
    }

    //i명의 사람이 있고, 체력의 한도가 j일 때 최대값을 저장하는 이차원 dp 배열
    //사람은 최대 20명, 체력은 최대 100이므로 배열의 크기는 (20+1)*(100+1)로 설정한다.
    var dp=Array(21,{IntArray(101,{0})})

    //1명에서부터 N명까지의 반복문을 돌린다.
    for(i in 1..N){
        //i명의 사람을 구성하는 구성원들에 대하여 반복문을 돌린다.
        for(j in 1 until dp[i].size){
            //만약 해당 사람이 소모하는 체력이 최대 소모 체력보다 크거나 같은 경우, 해당 dp값은 앞에서 가졌던 값, 즉 해당 사람을 포함하지 않는 최대값을 다시 가져온다.
            if(L[i]>=j){
                dp[i][j]=dp[i-1][j]
            }
            //그렇지 않은 경우,
            //1). 해당 사람이 포함되지 않는 이전 단계의 최대값
            //2). 해당 사람의 기쁨과 이전 단계에서 해당 사람의 체력소모 만큼 적을 때의 최대 기쁨을 더한 값
            //이 두 가지 값들 중 최대 값을 저장한다.
            else{
                dp[i][j]=Math.max(dp[i-1][j],J[i]+dp[i-1][j-L[i]])
            }
        }
    }
    
    println(dp[N][100])
    close()
}
```
