# 합분해

## 출처

* https://www.acmicpc.net/problem/2225

## 문제

* 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.

* 덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.

## 입력

* 첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.

## 출력

* 첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

## 입력 예제 1

```
20 2
```

## 출력 예제 1

```
21
```

## 입력 예제 2

```
6 4
```

## 출력 예제 2

```
84
```

## 풀이

* 문제는 K번 더해서 N이 되는 경우의 수를 구하는 건데, 이는 K-1개를 더해 N-(0부터 N까지의 정수)이 되는 경우의 수에 (0부터 N까지의 정수)를 한 번 더 더해 N을 만들면 된다.

* 구해야 하는 경우의 수를 DP[K][N]이라고 했을 때, 만약 입력에 7 3 가 주어졌다고 가정하면 이를

```
0+7

1+6

2+5

3+4

4+3

5+2

6+1

7+0
```

* 로 나눌 수 있다. 이를 하나씩 따져보면

```
0(2번 더해서 0이 되는 경우)+7(1번 더해서 7가 되는 경우)

1(2번 더해서 1이 되는 경우)+6(1번 더해서 6가 되는 경우)

2(2번 더해서 2이 되는 경우)+5(1번 더해서 5가 되는 경우)

3(2번 더해서 3이 되는 경우)+4(1번 더해서 4가 되는 경우)

4(2번 더해서 4이 되는 경우)+3(1번 더해서 3가 되는 경우)

5(2번 더해서 5이 되는 경우)+2(1번 더해서 2가 되는 경우)

6(2번 더해서 6이 되는 경우)+1(1번 더해서 1가 되는 경우)

7(2번 더해서 7이 되는 경우)+0(1번 더해서 0가 되는 경우)
```

* 즉 DP[2][5] = DP[1][0] + DP[1][1] + DP[1][2] + DP[1][3] + DP[1][4] + DP[1][5] 가 된다. 

* 이를 다시 K와 N으로 바꾸면 ```DP[K][N] = DP[K-1][0] + DP[K-1][1] + … + DP[K-1][N]``` 임을 알 수 있다.

* 이를 좀 더 쉽게 바꾸면 ```DP[K][N] = DP[K][N-1] + DP[K-1][N-1]```이 된다.

## 소스코드

```kotlin
package dynamicprograming

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.*

fun main() = with(BufferedReader(InputStreamReader(System.`in`))){
    val st = StringTokenizer(readLine())

    val N = st.nextToken().toInt()//N(1이상 200 이하의 자연수)
    val K = st.nextToken().toInt()//N을 분할하는 자연수의 개수 K(1이상 200 이하의 자연수)

    var dp = Array(K + 1, { IntArray(N + 1) } )//k번 더해서 n이 되는 경우의 수

    for(i in 1..K){
        dp[i][0] = 1//i번 더해서 0이 되는 경우는 i의 값에 상관 없이 1번 밖에 없으므로 1로 초기화
    }

    for(i in 1..K){
        for(j in 1..N){
           dp[i][j] = (dp[i][j-1] + dp[i-1][j])% 1000000000//답을 1,000,000,000으로 나눈 나머지를 출력한다.
        }
    }

    println(dp[K][N])

    close()
}
```
