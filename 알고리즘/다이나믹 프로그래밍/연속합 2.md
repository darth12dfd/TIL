# 연속합 2

## 출처

* https://www.acmicpc.net/problem/13398

## 문제

* n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다. 또, 수열에서 수를 하나 제거할 수 있다. (제거하지 않아도 된다)

* 예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 수를 제거하지 않았을 때의 정답은 12+21인 33이 정답이 된다.

* 만약, -35를 제거한다면, 수열은 10, -4, 3, 1, 5, 6, 12, 21, -1이 되고, 여기서 정답은 10-4+3+1+5+6+12+21인 54가 된다.

## 입력

* 첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

## 출력

* 첫째 줄에 답을 출력한다.

## 입력 예제 1

```
10
10 -4 3 1 5 6 -35 12 21 -1
```

## 출력 예제 1

```
54
```

## 풀이

### 문제 접근 아이디어

* 원소를 제거하지 않는 경우는 잘 알려진 연속합 문제와 동일

* 하지만 이 문제에서는 “원소를 하나 제거할 수 있다”는 조건이 추가되므로, 삭제 여부에 따라 상태를 나누어 동적 계획법(DP) 으로 해결

### DP 상태 정의

* 현재 위치에서 끝나는 연속합을 기준으로 다음 두 가지 상태를 정의한다.

```
dp0
→ 아직 원소를 삭제하지 않았고, 현재 위치에서 끝나는 최대 연속합
```

```
dp1
→ 이미 원소를 하나 삭제했고, 현재 위치에서 끝나는 최대 연속합
```

### 점화식

#### 삭제하지 않은 경우 (dp0)

* 기존 연속합 문제와 동일하다.

```
dp0 = max(이전 dp0 + 현재 값, 현재 값)
```

#### 하나를 삭제한 경우 (dp1)

* 두 가지 선택지가 존재한다.

1. 현재 원소를 삭제하는 경우
→ 이전까지는 삭제하지 않은 상태
→ dp0(이전)

2. 이미 삭제했고 현재 원소를 포함하는 경우
→ dp1(이전) + 현재 값

* 따라서 점화식은 다음과 같다.

```
dp1 = max(dp0(이전), dp1(이전) + 현재 값)
```

### 초기값 설정의 중요성

* 처음에는 아직 어떤 원소도 삭제할 수 없음

```
dp0 = 첫 번째 원소

dp1 = 존재하지 않는 상태
```

* dp1을 MIN_VALUE로 두고 계산하면 오버플로가 발생할 수 있으므로, dp1은 실제로 “삭제가 발생하는 순간”에만 생성.

### 알고리즘 흐름

* 첫 번째 원소로 dp0을 초기화.

* dp1은 아직 존재하지 않는 상태로 둔다.

* 두 번째 원소부터 끝까지 순회:

  - dp0 갱신

  - dp1이 없으면 dp0에서 생성

  - dp1이 있으면 점화식 적용

* 매 단계마다 dp0, dp1 중 최댓값으로 정답을 갱신.
 
## 소스코드

```kotlin
package dynamicprogramming

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer
import kotlin.math.max

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))
    val n = br.readLine().toInt()
    val st = StringTokenizer(br.readLine())

    val a = IntArray(n)
    for (i in 0 until n) a[i] = st.nextToken().toInt()

    var dp0 = a[0].toLong()   // 삭제 X
    var dp1: Long? = null    // 삭제 O (아직 존재하지 않음)
    var answer = dp0

    for (i in 1 until n) {
        val nextDp1 = if (dp1 == null) {
            dp0                 // 여기서 처음 "삭제" 발생
        } else {
            max(dp0, dp1 + a[i])
        }

        val nextDp0 = max(dp0 + a[i], a[i].toLong())

        dp0 = nextDp0
        dp1 = nextDp1

        answer = max(answer, max(dp0, dp1))
    }

    println(answer)
}

```
