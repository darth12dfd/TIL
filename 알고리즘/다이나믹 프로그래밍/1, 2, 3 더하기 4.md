# 1, 2, 3 더하기 4

## 출처

* https://www.acmicpc.net/problem/15989

## 문제

* 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 4가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 합을 이루고 있는 수의 순서만 다른 것은 같은 것으로 친다.

```
1+1+1+1
2+1+1 (1+1+2, 1+2+1)
2+2
1+3 (3+1)
```

* 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 10,000보다 작거나 같다.

## 출력

* 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.

## 입력 예제 1

```
3
4
7
10
```

## 출력 예제 1

```
4
8
14
```

## 풀이

* dp 배열을 만들어서 풀이한다. 이때 연산을 이루는 피연산자들이 동일하다면 (1+2+1, 1+1+2, 2+1+1), 다 같은 하나의 경우로 취급한다는 점을 생각한다.

* dp 배열을 2차원 배열로 한다. 행은 입력받은 숫자 n이고 열은 끝나는 숫자를 기준으로한다. 열의 크기는 3이다.

* 행의 값이 1,2,3인 경우, 그 값은 1로 고정된다.

```
dp[1][1] = 1
dp[2][1] = 1
dp[2][2] = 1
dp[3][1] = 1
dp[3][2] = 1
dp[3][3] = 1
```

* 이제 행의 값이 4 이상일 때부터 집중해보자. 

* 예를 들어 4일 때를 상정해보면, 4라는 값을 수식값이 1로 끝나게 하는 수식은 3을 만드는 수식 + 1이 된다. 즉, ```dp[4][1] = dp[3][1]```이 성립된다. 이를 일반식으로 표현하면 아래와 같다.

```
dp[n][1] = dp[n-1][1]
```

* 4라는 값을 2로 끝나게 하는 수식은 수식 2를 만들 때 끝값이 1인 경우와 2인 경우 모두를 고려해야 한다. 점화식으로 표현하면 다음과 가탇.

```
dp[n][2] = dp[n-2][1] + dp[n-2][2]
```

* 4라는 값을 3으로 끝나게 하는 수식은 수식 1을 만들깨 끝값이 1인 경우, 2인 경우, 3인 경우를 고려해야 한다. 일반식으로 표현하면 뒤의 2 경우는 0이 되지만 점화식으로 표현하면 아래와 같다.

```
dp[n][3] = dp[n-3][1] + dp[n-3][2] + dp[n-3][3]
```

* 특정값 n에 대하여 위의 세가지 점화식의 값을 구한 뒤, 세 값을 모두 더하면 문제의 답이 된다.

## 소스코드

```kotlin
package dynamicprograming

import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.InputStreamReader
import java.io.OutputStreamWriter

fun main() = with(BufferedReader(InputStreamReader(System.`in`))){
    val T = readLine().toInt()//테스트 케이스의 개수

    val bw = BufferedWriter(OutputStreamWriter(System.`out`))

    var dp = Array(10001, { IntArray( 4, { 0 }  ) } )//2차원 dp 배열(n을 만들 때 k로 끝나는 수식의 개수)

    dp[1][1] = 1
    dp[2][1] = 1
    dp[2][2] = 1
    dp[3][1] = 1
    dp[3][2] = 1
    dp[3][3] = 1

    for(i in 4..10000){
        dp[i][1] = dp[i-1][1]
        dp[i][2] = dp[i-2][1] + dp[i-2][2]
        dp[i][3] = dp[i-3][1] + dp[i-3][2] + dp[i-3][3]
    }


    for(i in 0 until T){
        val n = readLine().toInt()//정수 n(1이상 10000이하의 자연수)

        bw.write("${dp[n][1] + dp[n][2] + dp[n][3]}\n")
    }

    bw.flush()
    bw.close()

    close()
}
```
