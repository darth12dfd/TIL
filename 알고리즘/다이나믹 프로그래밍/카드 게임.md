# 카드게임

## 출처

* https://www.acmicpc.net/problem/11062

## 문제

* 근우와 명우는 재미있는 카드 게임을 하고 있다. N개의 카드가 일렬로 놓여 있다. 각 카드에는 점수가 적혀있다. 근우부터 시작하여 번갈아가면서 턴이 진행되는데 한 턴에는 가장 왼쪽에 있는 카드나 가장 오른쪽에 있는 카드를 가져갈 수 있다. 카드가 더 이상 남아있지 않을 때까지 턴은 반복된다. 게임의 점수는 자신이 가져간 카드에 적힌 수의 합이다.

* 근우와 명우는 서로 자신의 점수를 가장 높이기 위해 최선의 전략으로 게임에 임한다. 놓여있는 카드의 개수 N과 카드가 놓여있는 상태가 주어졌을 때 근우가 얻는 점수를 구하는 프로그램을 작성하시오.

* 예를 들어 카드가 [4, 3, 1, 2]로 놓여있다고 하자. 근우는 처음에 4가 적힌 카드를 가져가고, 명우는 3이 적힌 카드를 가져간다. 그리고 근우는 2가 적힌 카드를 가져가고, 명우는 마지막으로 1이 적힌 카드를 가져간다. 이때 근우와 명우는 최선의 전략으로 임했으며, 근우가 얻는 점수는 6이다.

## 입력

* 입력의 첫 줄에는 테스트케이스의 수 T(1 ≤ T ≤ 50)가 주어진다.

* 각 테스트케이스 마다 첫 줄에는 카드의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 두 번째 줄에는 N개의 자연수가 공백으로 구분되어 주어지는데, i번째로 주어지는 수는 왼쪽에서 i번째에 놓인 카드에 적힌 수를 의미한다. 카드에 적혀있는 수는 1이상 10,000이하다.

## 출력

* 각 테스트케이스마다 근우와 명우가 최선의 전략으로 임할 때 근우가 얻게되는 점수를 줄로 구분하여 출력한다.

## 입력 예제 1

```
2
4
1 2 5 2
9
1 1 1 1 2 2 2 2 2
```

## 출력 예제 1

```
6
8
```

## 풀이

* 양쪽이 최적으로 플레이할 때, 근우(선공)가 얻을 수 있는 최대 점수를 구하는 전형적인 게임 DP(구간 DP + 미니맥스) 문제.

* 핵심 아이디어:

    - 구간 [l..r]에서 현재 차례인 사람이 얻을 수 있는 최대 점수를 dp[l][r]로 두면 현재 사람이 왼쪽 카드를 가져가면 a[l]를 얻고, 남은 구간 [l+1..r]에서는 상대가 최적으로 dp[l+1][r]만큼 가져감.

    - 남은 구간의 총합을 sum(l+1,r)라고 하면, 현재 사람이 남은 구간에서 추가로 얻는 점수는 sum(l+1,r) - dp[l+1][r]

    - 따라서 왼쪽을 고르면 총점: a[l] + (sum(l+1,r) - dp[l+1][r])

    - 오른쪽도 동일하게 계산해서 더 큰 값을 선택하면 됨.

## 소스코드

```kotlin
import java.io.BufferedInputStream

private class FastScanner {
    private val input = BufferedInputStream(System.`in`)
    private val buffer = ByteArray(1 shl 16)
    private var len = 0
    private var ptr = 0

    private fun readByte(): Int {
        if (ptr >= len) {
            len = input.read(buffer)
            ptr = 0
            if (len <= 0) return -1
        }
        return buffer[ptr++].toInt()
    }

    fun nextInt(): Int {
        var c: Int
        do {
            c = readByte()
        } while (c <= 32 && c >= 0)

        var sign = 1
        var res = 0
        var ch = c
        if (ch == '-'.code) {
            sign = -1
            ch = readByte()
        }
        while (ch > 32 && ch >= 0) {
            res = res * 10 + (ch - '0'.code)
            ch = readByte()
        }
        return res * sign
    }
}

fun main() {
    val fs = FastScanner()
    val t = fs.nextInt()
    val sb = StringBuilder()

    repeat(t) {
        val n = fs.nextInt()
        val a = LongArray(n)
        for (i in 0 until n) a[i] = fs.nextInt().toLong()

        // prefix sum: ps[i] = a[0] + ... + a[i-1]
        val ps = LongArray(n + 1)
        for (i in 0 until n) ps[i + 1] = ps[i] + a[i]

        // 구간 합 함수
        fun sum(l: Int, r: Int): Long {
            if (l > r) return 0L
            return ps[r + 1] - ps[l]
        }

        // dp[l][r] = 현재 차례인 사람이 구간 [l..r]에서 얻을 수 있는 최대 점수
        val dp = Array(n) { LongArray(n) }

        // 길이 1인 구간: 카드 1장뿐이니 그대로 가져간다
        for (i in 0 until n) dp[i][i] = a[i]

        // 길이 2 이상 구간을 점점 늘려가며 채우기
        for (len in 2..n) {
            for (l in 0..(n - len)) {
                val r = l + len - 1

                // 1) 왼쪽 a[l]을 가져가는 경우
                // 남은 구간 [l+1..r]의 총합 - 상대가 최적으로 가져갈 점수(dp[l+1][r])
                val takeLeft = a[l] + (sum(l + 1, r) - dp[l + 1][r])

                // 2) 오른쪽 a[r]을 가져가는 경우
                val takeRight = a[r] + (sum(l, r - 1) - dp[l][r - 1])

                dp[l][r] = maxOf(takeLeft, takeRight)
            }
        }

        // 근우(선공)가 전체 구간에서 얻을 수 있는 최대 점수
        sb.append(dp[0][n - 1]).append('\n')
    }

    print(sb.toString())
}

```
