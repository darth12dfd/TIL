# 쉬운 계단수

## 출처

* https://www.acmicpc.net/problem/10844

## 문제

* 45656이란 수를 보자.
이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.
세준이는 수의 길이가 N인 계단 수가 몇 개 있는지 궁금해졌다.
N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)

## 입력

* 첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

## 출력

* 첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

## 입력 예제 1

```1```

## 출력 예제 1

```9```

## 입력 예제 2

```2```

## 출력 예제 2

```17```

## 풀이

* 계단수의 길이(N)와 해당 길이 만큼의 계단수 사이의 상관관계를 알아내기 위해 표를 만들어 보았다.

| N | 계단 수의 개수 |
| ---- | ---- |
| 1 | 9 |
| 2 | 17 |
| 3 | 32 |
| 4 | 61 |
| 5 | 116 |
| 6 | 222 |
| 7 | 424 |

* 위의 표 만으로는 도무지 그 관계를 파악하기 어려웠다. 그래서 경우를 좀더 세부적으로 나눠 보기로 했다.

* 계단 수의 길이에 따른 계단수의 개수를 종류별로 나눠서 그 값을 구해보았다. 계단수는 1부터 9까지의 자연수가 각각 맨 앞자리인 경우에 대하여 모두 분류할 수 있다. 즉 동적 배열을 이차원 배열의 형태로 활용하는 것이다. 이와 같은 방식으로 이차원 배열을 만들면 아래와 같다.

| | 1로 시작 | 2로 시작 | 3으로 시작 | 4로 시작 | 5로 시작 | 6으로 시작 | 7로 시작 | 8로 시작 | 9로 시작 |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 길이가 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 길이가 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 1 |
| 길이가 3 | 3 | 4 | 4 | 4 | 4 | 4 | 4 | 3 | 2 |

* 위의 표를 통하여서 다음과 같은 점화식들을 만들 수 있다.

* 위의 행렬을 dp라고 하며 행 번호를 i, 열 번호를 j라고 하자.

* 먼저 i가 1일 때, 즉 숫자가 1의 자리 숫자인 경우, 어떤 숫자에 관계없이 한 가지 경우 밖에 없다. 따라서 다음 식이 성립된다.

```i=1,dp[i][j]=1```

* 그 다음 i가 2이고 j가 1인 경우 즉, 십의자리 숫자이면서 동시에 1로 시작하는 계단수인 경우는 12와 10 총 두가지 이다. 이를 식으로 나타내면 다음과 같다. 

```dp[2][1]=2```

* 또한 i가 3 이상이고 j가 1인 경우는 다음과 같은 식이 성립한다.

```dp[i][j]=dp[i-2][j]+dp[i-1][j+1]```

* 그리고 i가 1이 아니고, j가 9일 때, 즉 십의자리 숫자 이상이면서 동시에 9로 시작하는 계단수인 경우, 다음과 같은 식이 성립한다.

```dp[i][9]=dp[i-1][8]```

* 그 외의 경우, 즉 i가 2 이상이고 j가 2이상 8이하일 경우 다음 식이 성립한다.

```dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]```

* 또한 이 dp배열에서 dp[num]배열의 합을 구해서 10억으로 나눠주면 된다. 이 때, sum() 메서드를 쓰거나, dp배열은 IntArray로 만들 경우 오버플로우가 발생하므로 dp배열을 LongArray로 만들고, sum() 메서드 대신 반복문으로 dp[num]배열의 합을 구한다. 

## 소스코드

```kotlin
import java.io.BufferedReader
import java.io.InputStreamReader

fun main()=with(BufferedReader(InputStreamReader(System.`in`))){
    val number=readLine().toInt()
    var dp=Array(number+1,{LongArray(10,{0})})//dp 배열

    //이 때 열은 j 값이 맨 앞자리였을 경우의 계단수의 수를 저장한다.

    for(i in 1 until dp.size){
        for(j in 1 until dp[i].size){
            //길이가 1인 계단수의 경우는 그 숫자 본인 말고는 1개 밖에 없다.
            if(i==1){
                dp[i][j]=1
            }
            else{
                if(j==1){
                    if(i==2){
                        dp[i][j]=2
                    }
                    else{
                        dp[i][j]=(dp[i-2][j]+dp[i-1][j+1])%1000000000
                    }
                }
                else if(j==9){
                    dp[i][j]=dp[i-1][j-1]%1000000000
                }
                else {
                    dp[i][j]=(dp[i-1][j-1]+dp[i-1][j+1])%1000000000
                }
            }

        }
    }
    var result:Long=0
    //합계 출력
    for(i in 1 until dp[number].size){
        result+=dp[number][i]
    }
    println(result%1000000000)
    close()
}
```
