# 우수 마을

## 출처

* https://www.acmicpc.net/problem/1949

## 문제

* N개의 마을로 이루어진 나라가 있다. 편의상 마을에는 1부터 N까지 번호가 붙어 있다고 하자. 이 나라는 트리(Tree) 구조로 이루어져 있다. 즉 마을과 마을 사이를 직접 잇는 N-1개의 길이 있으며, 각 길은 방향성이 없어서 A번 마을에서 B번 마을로 갈 수 있다면 B번 마을에서 A번 마을로 갈 수 있다. 또, 모든 마을은 연결되어 있다. 두 마을 사이에 직접 잇는 길이 있을 때, 두 마을이 인접해 있다고 한다.

* 이 나라의 주민들에게 성취감을 높여 주기 위해, 다음 세 가지 조건을 만족하면서 N개의 마을 중 몇 개의 마을을 '우수 마을'로 선정하려고 한다.

1. '우수 마을'로 선정된 마을 주민 수의 총 합을 최대로 해야 한다.
2. 마을 사이의 충돌을 방지하기 위해서, 만일 두 마을이 인접해 있으면 두 마을을 모두 '우수 마을'로 선정할 수는 없다. 즉 '우수 마을'끼리는 서로 인접해 있을 수 없다.
3. 선정되지 못한 마을에 경각심을 불러일으키기 위해서, '우수 마을'로 선정되지 못한 마을은 적어도 하나의 '우수 마을'과는 인접해 있어야 한다.

* 각 마을 주민 수와 마을 사이의 길에 대한 정보가 주어졌을 때, 주어진 조건을 만족하도록 '우수 마을'을 선정하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 정수 N이 주어진다. (1 ≤ N ≤ 10,000) 둘째 줄에는 마을 주민 수를 나타내는 N개의 자연수가 빈칸을 사이에 두고 주어진다. 1번 마을부터 N번 마을까지 순서대로 주어지며, 주민 수는 10,000 이하이다. 셋째 줄부터 N-1개 줄에 걸쳐서 인접한 두 마을의 번호가 빈칸을 사이에 두고 주어진다.

## 출력

* 첫째 줄에 '우수 마을'의 주민 수의 총 합을 출력한다.

## 입력 예제 1

```
7
1000 3000 4000 1000 2000 2000 7000
1 2
2 3
4 3
4 5
6 2
6 7
```

## 출력 예제 1

```
14000
```

## 문제 핵심 요약

* N개의 마을이 트리 형태로 연결되어 있고, 각 마을은 주민 수가 있음.

* “우수 마을”을 선택할 때:

  1. 서로 인접한 마을끼리는 동시에 우수 마을이 될 수 없다.

  2. 우수 마을로 선택되지 않은 마을은 적어도 하나의 우수 마을과 인접해야 한다.

* 목표는 우수 마을 주민 수의 합의 최댓값 출력.

* 이 조건은 독립집합 문제와 비슷하며, 트리 DP로 해결

## 해결 전략 (DP 정의)

* 각 노드 u에 대해 두 가지 상태를 계산

```
dp[u][0]: u가 우수 마을이 아닐 때의 최대 주민 수 합
dp[u][1]: u가 우수 마을일 때의 최대 주민 수 합
```

* u가 우수 마을이면 → 모든 자식은 우수 마을이 될 수 없음
→ dp[u][1] += dp[child][0]

* u가 우수 마을이 아닐 때는 → 자식은 우수 마을이거나 아니거나 선택 가능
→ dp[u][0] += max(dp[child][0], dp[child][1])

* 그리고 DFS로 트리를 탐색하면서 dp 값을 채워 나가면 

## 소스코드

```kotlin
package dynamicprogramming

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.StringTokenizer
import java.util.ArrayList

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))
    val n = br.readLine().trim().toInt()

    val st = StringTokenizer(br.readLine())
    val population = IntArray(n + 1)
    for (i in 1..n) {
        population[i] = st.nextToken().toInt()
    }

    // adjacency list
    val tree = Array(n + 1) { ArrayList<Int>() }
    repeat(n - 1) {
        val line = StringTokenizer(br.readLine())
        val u = line.nextToken().toInt()
        val v = line.nextToken().toInt()
        tree[u].add(v)
        tree[v].add(u)
    }

    // dp[node][0 or 1]
    val dp = Array(n + 1) { IntArray(2) }
    val visited = BooleanArray(n + 1)

    fun dfs(cur: Int) {
        visited[cur] = true
        dp[cur][0] = 0
        dp[cur][1] = population[cur]

        for (next in tree[cur]) {
            if (!visited[next]) {
                dfs(next)
                // if cur is not selected => child can be selected or not
                dp[cur][0] += maxOf(dp[next][0], dp[next][1])
                // if cur is selected => child must NOT be selected
                dp[cur][1] += dp[next][0]
            }
        }
    }

    // root at 1
    dfs(1)
    val answer = maxOf(dp[1][0], dp[1][1])
    println(answer)
}
```
