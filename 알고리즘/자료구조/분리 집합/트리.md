# 트리

## 출처

* https://www.acmicpc.net/problem/4803

## 문제

* 그래프는 정점과 간선으로 이루어져 있다. 두 정점 사이에 경로가 있다면, 두 정점은 연결되어 있다고 한다. 연결 요소는 모든 정점이 서로 연결되어 있는 정점의 부분집합이다. 그래프는 하나 또는 그 이상의 연결 요소로 이루어져 있다.

* 트리는 사이클이 없는 연결 요소이다. 트리에는 여러 성질이 있다. 예를 들어, 트리는 정점이 n개, 간선이 n-1개 있다. 또, 임의의 두 정점에 대해서 경로가 유일하다.

* 그래프가 주어졌을 때, 트리의 개수를 세는 프로그램을 작성하시오.

## 입력

* 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스의 첫째 줄에는 n ≤ 500과 m ≤ n(n-1)/2을 만족하는 정점의 개수 n과 간선의 개수 m이 주어진다. 다음 m개의 줄에는 간선을 나타내는 두 개의 정수가 주어진다. 같은 간선은 여러 번 주어지지 않는다. 정점은 1번부터 n번까지 번호가 매겨져 있다. 입력의 마지막 줄에는 0이 두 개 주어진다.

## 출력

* 입력으로 주어진 그래프에 트리가 없다면 "No trees."를, 한 개라면 "There is one tree."를, T개(T > 1)라면 "A forest of T trees."를 테스트 케이스 번호와 함께 출력한다.

## 입력 예제 1

```
6 3
1 2
2 3
3 4
6 5
1 2
2 3
3 4
4 5
5 6
6 6
1 2
2 3
1 3
4 5
5 6
6 4
0 0
```

## 출력 예제 1

```
Case 1: A forest of 3 trees.
Case 2: There is one tree.
Case 3: No trees.
```

## 풀이

* 문제에서 트리의 조건은 2가지로 본다

```
1. 연결되어 있어야 함
2. 사이클이 없어야 함
```

=> “사이클이 없는 연결 요소의 개수” 를 세면 됨.

* 분리집합으로 풀이해보기(유니온 & 파인드 함수 사용)

* 우선 세가지 배열을 만듦

```kotlin
val parent = IntArray(n + 1) { it } //i가 속한 집합의 부모
val size = IntArray(n + 1) { 1 } //루트 기준 집합 크기
val hasCycle = BooleanArray(n + 1) { false } //이 집합(루트)이 사이클을 갖는지 여부
```

* 파인드 함수 설정: x가 속한 연결 요소의 대표(루트) 를 찾음. 경로 압축으로 이후 연산을 빠르게 함

```kotlin
fun find(x: Int): Int {
    var v = x
    while (parent[v] != v) v = parent[v]
    val root = v

    // path compression
    var cur = x
    while (parent[cur] != cur) {
        val p = parent[cur]
        parent[cur] = root
        cur = p
    }
    return root
}

```

* 유니온 함수 설정

```kotlin
 fun union(a: Int, b: Int) {
            val ra = find(a)
            val rb = find(b)

            // 같은 컴포넌트 안에서 또 연결 => 사이클 발생
            if (ra == rb) {
                hasCycle[ra] = true
                return
            }

            // union by size
            if (size[ra] < size[rb]) {
                parent[ra] = rb
                size[rb] += size[ra]
                hasCycle[rb] = hasCycle[rb] || hasCycle[ra]
            } else {
                parent[rb] = ra
                size[ra] += size[rb]
                hasCycle[ra] = hasCycle[ra] || hasCycle[rb]
            }
        }
```

* 그후 parent 배열을 돌면서 값이 있고 해당 x에서 사이클이 없을 경우 트리 개수 증가 하면 됨.

## 소스코드

```kotlin
import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.InputStreamReader
import java.io.OutputStreamWriter
import java.util.StringTokenizer

fun main() = with(BufferedReader(InputStreamReader(System.`in`))) {

    val bw = BufferedWriter(OutputStreamWriter(System.out))

    var T = 0 // 테스트 케이스 개수(=Case 번호)

    while (true) {
        // ✅ n, m 읽기 (라인 단위로 안전하게)
        var st = StringTokenizer(readLine())
        val n = st.nextToken().toInt()
        val m = st.nextToken().toInt()

        // 그래프 집합 끝나면 종료
        if (n == 0 && m == 0) break

        T++ // 테스트케이스 번호 증가

        // ---------------------------
        // ✅ Union-Find 준비
        // ---------------------------
        val parent = IntArray(n + 1) { it }
        val size = IntArray(n + 1) { 1 }
        val hasCycle = BooleanArray(n + 1) { false } // 루트 기준 사이클 존재 여부

        fun find(x: Int): Int {
            var v = x
            while (parent[v] != v) v = parent[v]
            val root = v
            // path compression
            var cur = x
            while (parent[cur] != cur) {
                val p = parent[cur]
                parent[cur] = root
                cur = p
            }
            return root
        }

        fun union(a: Int, b: Int) {
            val ra = find(a)
            val rb = find(b)

            // 같은 컴포넌트 안에서 또 연결 => 사이클 발생
            if (ra == rb) {
                hasCycle[ra] = true
                return
            }

            // union by size
            if (size[ra] < size[rb]) {
                parent[ra] = rb
                size[rb] += size[ra]
                hasCycle[rb] = hasCycle[rb] || hasCycle[ra]
            } else {
                parent[rb] = ra
                size[ra] += size[rb]
                hasCycle[ra] = hasCycle[ra] || hasCycle[rb]
            }
        }

        // ---------------------------
        // ✅ 간선 입력 처리
        // ---------------------------
        for (i in 0 until m) {
            st = StringTokenizer(readLine())
            val v1 = st.nextToken().toInt()
            val v2 = st.nextToken().toInt()
            union(v1, v2)
        }

        // ---------------------------
        // ✅ 트리 개수 세기
        // 트리 컴포넌트 = 사이클 없는 컴포넌트
        // ---------------------------
        var tree_count = 0
        for (i in 1..n) {
            if (parent[i] == i && !hasCycle[i]) tree_count++
        }

        // ---------------------------
        // ✅ 출력
        // ---------------------------
        if (tree_count == 0) {
            bw.write("Case $T: No trees.\n")
        } else if (tree_count == 1) {
            bw.write("Case $T: There is one tree.\n")
        } else {
            bw.write("Case $T: A forest of $tree_count trees.\n")
        }
    }

    bw.flush()
    bw.close()
    close()
}

```
