# 외계인의 기타연주

## 출처

* https://www.acmicpc.net/problem/2841

## 문제

* 상근이의 상상의 친구 외계인은 손가락을 수십억개 가지고 있다. 어느 날 외계인은 기타가 치고 싶었고, 인터넷에서 간단한 멜로디를 검색했다. 이제 이 기타를 치려고 한다.

* 보통 기타는 1번 줄부터 6번 줄까지 총 6개의 줄이 있고, 각 줄은 P개의 프렛으로 나누어져 있다. 프렛의 번호도 1번부터 P번까지 나누어져 있다.

* 멜로디는 음의 연속이고, 각 음은 줄에서 해당하는 프렛을 누르고 줄을 튕기면 연주할 수 있다. 예를 들면, 4번 줄의 8번 프렛을 누르고 튕길 수 있다. 만약, 어떤 줄의 프렛을 여러 개 누르고 있다면, 가장 높은 프렛의 음이 발생한다.

* 예를 들어, 3번 줄의 5번 프렛을 이미 누르고 있다고 하자. 이때, 7번 프렛을 누른 음을 연주하려면, 5번 프렛을 누르는 손을 떼지 않고 다른 손가락으로 7번 프렛을 누르고 줄을 튕기면 된다. 여기서 2번 프렛의 음을 연주하려고 한다면, 5번과 7번을 누르던 손가락을 뗀 다음에 2번 프렛을 누르고 연주해야 한다.

* 이렇게 손가락으로 프렛을 한 번 누르거나 떼는 것을 손가락을 한 번 움직였다고 한다. 어떤 멜로디가 주어졌을 때, 손가락의 가장 적게 움직이는 회수를 구하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 멜로디에 포함되어 있는 음의 수 N과 한 줄에 있는 프렛의 수 P가 주어진다. (N ≤ 500,000, 2 ≤ P ≤ 300,000)

* 다음 N개 줄에는 멜로디의 한 음을 나타내는 두 정수가 주어진다. 첫 번째 정수는 줄의 번호이고 두 번째 정수는 그 줄에서 눌러야 하는 프렛의 번호이다. 입력으로 주어진 음의 순서대로 기타를 연주해야 한다.

## 출력

* 첫째 줄에 멜로디를 연주하는데 필요한 최소 손가락 움직임을 출력한다.

## 입력 예제 1

```
5 15
2 8
2 10
2 12
2 10
2 5
```

## 출력 예제 1

```
7
```

## 입력 예제 2

```
7 15
1 5
2 3
2 5
2 7
2 4
1 5
1 3
```

## 출력 예제 2

```
9
```

## 풀이

* 이 경우에는 스택을 배열로 만들어서 활용한다. 줄에 따라서 스택에 넣어야 할지 말아야 하맂도 정해야 되기 때문에, 스택 배열을 만들어서 줄이 같은 음들은 같은 행에 삽입해준다.

* 그리고 같은 줄에 대하여 스택 연산을 실행하면 되는데, 입력받은 fret 값이 스택에 있는 fret 값보다 큰 경우 입력 받은 fret을 스택에 넣어주고, 작은 경우는 스택에 있는 값을 스택에서 빼준다. 같은 경우에는 반복문을 종료한다.

* 위의 과정에서 같은 경우를 제외한 경우에 대하여 결과값을 1씩 증가시킨다. 

* 만약 처음에 스택이 비어있는 경우 스택에 초깃값을 추가한다. 그리고 결과값을 1씩 증가시킨다.

## 소스코드

```kotlin
package datastructure.stack

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.*

fun main() = with(BufferedReader(InputStreamReader(System.`in`))){
    var st = StringTokenizer(readLine())
    
    val N = st.nextToken().toInt()//음의 수(50만 이하의 자연수)
    val P = st.nextToken().toInt()//프렛의 수(2 이상 30만 이하의 자연수)

    var stack= Array<Stack<Int>>(7,{Stack<Int>()})//스택 배열 생성

    var answer = 0//손가락 움직임 횟수를 저장할 변수

    for(i in 0 until N){
        st = StringTokenizer(readLine())

        val string = st.nextToken().toInt()//줄의 번호
        val fret = st.nextToken().toInt()//프렛의 번호
        
        //해당 줄의 스택이 비어있지 않았을 경우 반복문 실행
        while(stack[string].isNotEmpty()){
            //현재 프랫이 이전의 프랫보다 큰 경우
            if(fret > stack[string].peek()){
                stack[string].push(fret)//스텍에 현재 fret을 push
            }
            
            //현재 프랫이 이전의 프랫보다 작은 경우
            else if(fret < stack[string].peek()){
                stack[string].pop()//스택에서 이전의 fret을 pop
            }

            else{//같은 경우 반복문 탈출
                break
            }

            answer += 1//스택에서 빼든 넣든 결과적으로 하나의 행동이 수행되므로 결과값을 1 증가시킨다.
        }

        //만약 스택이 비어있는 경우 스택에 추가한다. 그리고 결과값을 1 증가시킨다.
        if(stack[string].isEmpty()){
            stack[string].push(fret)
            answer += 1
        }
    }

    println(answer)

    close()
}
```
