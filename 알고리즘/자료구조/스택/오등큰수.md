# 오등큰수

## 출처

* https://www.acmicpc.net/problem/17299

## 문제

* 크기가 N인 수열 A = A1, A2, ..., AN이 있다. 수열의 각 원소 Ai에 대해서 오등큰수 NGF(i)를 구하려고 한다.

* Ai가 수열 A에서 등장한 횟수를 F(Ai)라고 했을 때, Ai의 오등큰수는 오른쪽에 있으면서 수열 A에서 등장한 횟수가 F(Ai)보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오등큰수는 -1이다.

* 예를 들어, A = [1, 1, 2, 3, 4, 2, 1]인 경우 F(1) = 3, F(2) = 2, F(3) = 1, F(4) = 1이다. A1의 오른쪽에 있으면서 등장한 횟수가 3보다 큰 수는 없기 때문에, NGF(1) = -1이다. A3의 경우에는 A7이 오른쪽에 있으면서 F(A3=2) < F(A7=1) 이기 때문에, NGF(3) = 1이다. NGF(4) = 2, NGF(5) = 2, NGF(6) = 1 이다.

## 입력

* 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째에 수열 A의 원소 A1, A2, ..., AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.

## 출력

* 총 N개의 수 NGF(1), NGF(2), ..., NGF(N)을 공백으로 구분해 출력한다.

## 입력 예제 1

```
7
1 1 2 3 4 2 1
```

## 출력 예제 1

```
-1 -1 1 2 2 1 -1
```

## 풀이

* 오큰수 문제에서 큰 값이 아닌 큰 빈도가 더 중요한 문제로 바뀐거 말고는 기존 오큰수 문제에서 큰 변화는 없는 문제이다.

* 쉽게말해서 값이 커도 빈도수가 작으면 안되고 반대로 값이 작더라도 빈도수가 크면 오등큰수가 될 수 있다.

```
오큰수  = 값 비교 + 스택
오등큰수 = 빈도 비교 + 스택
구조는 동일, 판단 기준만 다름
```

* 나머지는 아래의 오큰수를 찾는 방식과 동일하다

```
1. 오른쪽에서 처음 만나는 대상을 찾는다
2. 스택을 사용한다
3. 스택에는 인덱스를 넣는다
4. 한 번의 순회로 해결
```

## 소스코드

```kotlin
package datastructure.stack

import java.io.BufferedReader
import java.io.BufferedWriter
import java.io.InputStreamReader
import java.io.OutputStreamWriter
import java.util.*

fun main() = with(BufferedReader(InputStreamReader(System.`in`))){
    val N = readLine().toInt()//수열 N의 크기

    val A = IntArray(N)//수열 A

    val st = StringTokenizer(readLine())

    for(i in 0 until N){
        A[i] = st.nextToken().toInt()
    }

    //등장 빈도 F 계산
    val F = IntArray(1_000_001)

    for(i in 0 until N){
        F[A[i]]++
    }

    //오등큰수 구하기(맨 처음 -1로 초기화)
    val NG = IntArray(N) { -1 }

    var stack = Stack<Int>()//스택 만들기

    for(i in 0 until N){
        //스택이 비어있지 않거나 스택에 제일 위의 값(현재 순서)의 빈도가 반복문의 현재 빈도값보다 작은경우
        while(stack.isNotEmpty() && F[A[stack.peek()]] < F[A[i]]){
            NG[stack.pop()] = A[i]//스택에 있는 인덱스는 A[i]의 값으로 넣기
        }
        stack.push(i)//스택에 인덱스 삽입
    }

    val bw = BufferedWriter(OutputStreamWriter(System.`out`))

    for (i in 0 until N) {
        bw.write("${NG[i]} ")
    }

    bw.flush()
    bw.close()
    close()
}
```
