# 중앙값 구하기

## 출처

* https://www.acmicpc.net/problem/2696

## 문제

* 어떤 수열을 읽고, 홀수번째 수를 읽을 때 마다, 지금까지 입력받은 값의 중앙값을 출력하는 프로그램을 작성하시오.

* 예를 들어, 수열이 1, 5, 4, 3, 2 이면, 홀수번째 수는 1번째 수, 3번째 수, 5번째 수이고, 1번째 수를 읽었을 때 중앙값은 1, 3번째 수를 읽었을 때는 4, 5번째 수를 읽었을 때는 3이다.

## 입력

* 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스의 첫째 줄에는 수열의 크기 M(1 ≤ M ≤ 9999, M은 홀수)이 주어지고, 그 다음 줄부터 이 수열의 원소가 차례대로 주어진다. 원소는 한 줄에 10개씩 나누어져있고, 32비트 부호있는 정수이다.

## 출력

* 각 테스트 케이스에 대해 첫째 줄에 출력하는 중앙값의 개수를 출력하고, 둘째 줄에는 홀수 번째 수를 읽을 때 마다 구한 중앙값을 차례대로 공백으로 구분하여 출력한다. 이때, 한 줄에 10개씩 출력해야 한다.

## 입력 예제 1

```
3
9
1 2 3 4 5 6 7 8 9
9
9 8 7 6 5 4 3 2 1
23
23 41 13 22 -3 24 -31 -11 -8 -7
3 5 103 211 -311 -45 -67 -73 -81 -99
-33 24 56
```

## 출력 예제 1

```
5
1 2 3 4 5
5
9 8 7 6 5
12
23 23 22 22 13 3 5 5 3 -3
-7 -3
```

## 풀이

* 입력되는 수열을 앞에서부터 하나씩 처리하면서 홀수번째 입력이 들어올 때마다 현재까지의 중앙값을 기록해야 함.

* 이럴 때마다 전체를 정렬하는 것은 비효율적이므로 → 두 개의 힙 (우선순위 큐) 을 활용:
  - maxHeap: 중앙값 이하의 값들 (최대 힙)
  - minHeap: 중앙값 초과의 값들 (최소 힙)

* 두 힙의 크기를 잘 조정하면 항상 maxHeap.peek()이 current median이 됨.

## 소스코드

```kotlin
package datastructure.priorityqueue

import java.io.BufferedInputStream
import java.io.BufferedOutputStream
import java.io.PrintWriter
import java.util.PriorityQueue
import java.util.Comparator

fun main() {
    val input = BufferedInputStream(System.`in`)
    val out = PrintWriter(BufferedOutputStream(System.out))

    // 빠른 정수 입력 헬퍼
    fun readInt(): Int {
        var result = 0
        var read = input.read()
        while (read <= ' '.toInt() && read != -1) {
            read = input.read()
        }
        val neg = (read == '-'.toInt())
        if (neg) read = input.read()
        while (read in '0'.toInt()..'9'.toInt()) {
            result = result * 10 + (read - '0'.toInt())
            read = input.read()
        }
        return if (neg) -result else result
    }

    val T = readInt()
    repeat(T) {
        val M = readInt()

        // 중앙값 개수 출력
        val medianCount = (M + 1) / 2
        out.println(medianCount)

        val maxHeap = PriorityQueue<Int>(Comparator { a, b -> b - a }) // 중앙 이하
        val minHeap = PriorityQueue<Int>() // 중앙 초과

        var printed = 0
        val medians = mutableListOf<Int>()

        for (i in 0 until M) {
            val x = readInt()

            // 힙에 넣을 때 크기 균형 맞춤
            if (maxHeap.size == minHeap.size) {
                maxHeap.offer(x)
            } else {
                minHeap.offer(x)
            }

            // 항상 maxHeap.peek() <= minHeap.peek() 정렬 유지
            if (minHeap.isNotEmpty() && maxHeap.peek() > minHeap.peek()) {
                val a = maxHeap.poll()
                val b = minHeap.poll()
                maxHeap.offer(b)
                minHeap.offer(a)
            }

            // 홀수번째라면 중앙값 기록
            if (i % 2 == 0) {
                medians.add(maxHeap.peek())
            }
        }

        // 출력: 한 줄에 10개씩
        var cntLine = 0
        for (i in medians.indices) {
            out.print(medians[i])
            printed++
            cntLine++
            if (printed < medianCount) {
                if (cntLine == 10) {
                    out.println()
                    cntLine = 0
                } else {
                    out.print(" ")
                }
            }
        }
        out.println()
    }

    out.flush()
}

```
