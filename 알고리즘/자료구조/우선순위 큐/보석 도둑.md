# 보석 도둑

## 출처

* https://www.acmicpc.net/problem/1202

## 문제

* 세계적인 도둑 상덕이는 보석점을 털기로 결심했다.

* 상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.

* 상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.

## 입력

* 첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)

* 다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi ≤ 1,000,000)

* 다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci ≤ 100,000,000)

* 모든 숫자는 양의 정수이다.

## 출력

* 첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.

## 입력 예제 1

```
2 1
5 10
100 100
11
```

## 출력 예제 1

```
10
```

## 입력 예제 2

```
3 2
1 65
5 23
2 99
10
2
```

## 출력 예제 2

```
164
```

## 풀이

1. 보석들을 무게 M 기준 오름차순으로 정렬

2. 가방들도 최대 무게 C 기준 오름차순으로 정렬

3. 작은 가방부터 차례대로 처리하면서 해당 가방이 담을 수 있는 보석들 (M ≤ C) 를 모두 우선순위 큐(가격 내림차순) 에 넣고 큐에서 가장 비싼 보석을 꺼내 가방에 넣고 그 가격을 누적한다

4. 모든 가방 처리 후의 누적 가격이 답

## 소스코드

```kotlin
package datastructure.priorityqueue

import java.io.BufferedInputStream
import java.io.PrintWriter
import java.util.PriorityQueue

data class Jewel(val weight: Int, val value: Int)

fun main() {
    val input = BufferedInputStream(System.`in`)
    val sb = StringBuilder()
    val buf = ByteArray(1 shl 16)
    var idx = 0
    var size = 0

    fun read(): Int {
        if (size == -1) return 0
        if (idx >= size) {
            size = input.read(buf)
            idx = 0
        }
        return if (size <= 0) 0 else buf[idx++].toInt() and 0xFF
    }

    fun readInt(): Int {
        var c = read()
        while (c != 0 && c <= ' '.toInt()) {
            c = read()
        }
        var result = 0
        while (c in '0'.toInt()..'9'.toInt()) {
            result = result * 10 + (c - '0'.toInt())
            c = read()
        }
        return result
    }

    val n = readInt()
    val k = readInt()

    val jewels = ArrayList<Jewel>(n)
    for (i in 0 until n) {
        val m = readInt()
        val v = readInt()
        jewels.add(Jewel(m, v))
    }

    // 가방 무게 리스트
    val bagCap = LongArray(k)
    for (i in 0 until k) {
        bagCap[i] = readInt().toLong()
    }

    // 보석 무게 기준으로 오름차순 정렬
    jewels.sortWith(compareBy<Jewel> { it.weight })

    // 가방도 오름차순 정렬
    bagCap.sort()

    // Max Heap(우선순위 큐) – value 기준 내림차순
    val pq = PriorityQueue<Int>(k) { a, b -> b - a }

    var jIndex = 0
    var total = 0L

    for (cap in bagCap) {
        while (jIndex < n && jewels[jIndex].weight.toLong() <= cap) {
            pq.add(jewels[jIndex].value)
            jIndex++
        }
        if (pq.isNotEmpty()) {
            total += pq.poll().toLong()
        }
    }

    val out = PrintWriter(System.out)
    out.print(total)
    out.flush()
}

```
