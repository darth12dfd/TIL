# 소수 경로

## 출처

* https://www.acmicpc.net/problem/1963

## 문제

* 소수를 유난히도 좋아하는 창영이는 게임 아이디 비밀번호를 4자리 ‘소수’로 정해놓았다. 어느 날 창영이는 친한 친구와 대화를 나누었는데:

```
“이제 슬슬 비번 바꿀 때도 됐잖아”
“응 지금은 1033으로 해놨는데... 다음 소수를 무엇으로 할지 고민중이야"
“그럼 8179로 해”
“흠... 생각 좀 해볼게. 이 게임은 좀 이상해서 비밀번호를 한 번에 한 자리 밖에 못 바꾼단 말이야. 예를 들어 내가 첫 자리만 바꾸면 8033이 되니까 소수가 아니잖아. 여러 단계를 거쳐야 만들 수 있을 것 같은데... 예를 들면... 1033 1733 3733 3739 3779 8779 8179처럼 말이야.”
“흠...역시 소수에 미쳤군. 그럼 아예 프로그램을 짜지 그래. 네 자리 소수 두 개를 입력받아서 바꾸는데 몇 단계나 필요한지 계산하게 말야.”
“귀찮아”
```

* 그렇다. 그래서 여러분이 이 문제를 풀게 되었다. 입력은 항상 네 자리 소수만(1000 이상) 주어진다고 가정하자. 주어진 두 소수 A에서 B로 바꾸는 과정에서도 항상 네 자리 소수임을 유지해야 하고, ‘네 자리 수’라 하였기 때문에 0039 와 같은 1000 미만의 비밀번호는 허용되지 않는다.

## 입력

* 첫 줄에 test case의 수 T가 주어진다. 다음 T줄에 걸쳐 각 줄에 1쌍씩 네 자리 소수가 주어진다.

## 출력 

* 각 test case에 대해 두 소수 사이의 변환에 필요한 최소 회수를 출력한다. 불가능한 경우 Impossible을 출력한다.

## 입력 예제 1

```
3
1033 8179
1373 8017
1033 1033
```

## 출력 예제 1

```
6
7
0
```

## 풀이

1. 에라토스테네스의 체로 0~9999 범위의 소수 여부를 미리 구함.

2. 각 테스트 케이스마다 BFS(queue)로 탐색하면서

  - 현재 숫자의 각 자리수를 0~9로 바꿔보고

  - 해당 숫자가 소수이면서 **네 자리(>=1000)**이면 방문

3. 목표 숫자에 도달하면 그 횟수(steps)를 출력

4. 도달하지 못하면 "Impossible"을 출력

## 소스코드

```kotlin
package mathematics.numbertheory

import java.io.BufferedReader
import java.io.InputStreamReader
import java.util.LinkedList
import java.util.Queue
import java.util.StringTokenizer

fun main() {
    val br = BufferedReader(InputStreamReader(System.`in`))

    // 에라토스테네스의 체로 1000 ~ 9999 사이의 소수 여부를 판별
    val isPrime = BooleanArray(10000) { true }
    isPrime[0] = false
    isPrime[1] = false
    for (i in 2..9999) {
        if (isPrime[i]) {
            var j = i * 2
            while (j <= 9999) {
                isPrime[j] = false
                j += i
            }
        }
    }

    // 테스트 케이스 개수
    val t = br.readLine().toInt()

    repeat(t) {
        val st = StringTokenizer(br.readLine())
        val start = st.nextToken().toInt()
        val end = st.nextToken().toInt()

        if (start == end) {
            println(0)
            return@repeat
        }

        val visited = BooleanArray(10000)

        // BFS: Pair(number, steps)
        val queue: Queue<Pair<Int, Int>> = LinkedList()
        queue.add(Pair(start, 0))
        visited[start] = true

        var result: Int? = null

        while (queue.isNotEmpty()) {
            val (current, steps) = queue.poll()

            // 현재 숫자를 문자열로 바꿔서 자릿수별로 바꿔본다.
            val currStr = current.toString().padStart(4, '0')

            for (i in 0 until 4) {
                for (d in '0'..'9') {
                    if (currStr[i] == d) continue

                    val newNumString = StringBuilder(currStr).also { it.setCharAt(i, d) }.toString()
                    val newNum = newNumString.toInt()

                    // 네 자리 범위(1000 이상), 소수이고 방문하지 않은 경우 큐에 추가
                    if (newNum >= 1000 && isPrime[newNum] && !visited[newNum]) {
                        if (newNum == end) {
                            result = steps + 1
                            break
                        }
                        visited[newNum] = true
                        queue.add(Pair(newNum, steps + 1))
                    }
                }
                if (result != null) break
            }
            if (result != null) break
        }

        // 출력
        if (result != null) println(result) else println("Impossible")
    }
}
```
